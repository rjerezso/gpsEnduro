<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Enduro Route Planner - GPS Off-Road</title>
    
    <!-- PWA Meta Tags -->
    <meta name="description" content="GPS Off-Road para rutas de enduro - Evita asfalto, busca caminos de tierra">
    <meta name="theme-color" content="#f97316">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="EnduroGPS">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="msapplication-TileColor" content="#111827">
    <meta name="msapplication-tap-highlight" content="no">
    
    <!-- Manifest -->
    <link rel="manifest" href="./manifest.json">
    
    <!-- Icons -->
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 512 512'><rect fill='%23111827' width='512' height='512' rx='64'/><circle cx='256' cy='280' r='140' fill='none' stroke='%23f97316' stroke-width='24'/><circle cx='256' cy='280' r='60' fill='%23f97316'/><polygon points='256,80 276,140 236,140' fill='%23f97316'/></svg>">
    <link rel="apple-touch-icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 512 512'><rect fill='%23111827' width='512' height='512' rx='64'/><circle cx='256' cy='280' r='140' fill='none' stroke='%23f97316' stroke-width='24'/><circle cx='256' cy='280' r='60' fill='%23f97316'/><polygon points='256,80 276,140 236,140' fill='%23f97316'/></svg>">
    
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
    <style>
        * {
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
        }
        
        html, body {
            touch-action: manipulation;
            overscroll-behavior: none;
        }
        
        #map { 
            height: 100vh; 
            height: 100dvh;
            width: 100%; 
            position: fixed !important;
            top: 0;
            left: 0;
            z-index: 1;
        }
        .leaflet-container { 
            font-family: inherit;
            background: #1a1a2e !important;
        }
        .leaflet-tile-pane {
            z-index: 2 !important;
        }
        .leaflet-control-zoom {
            display: none !important;
        }
        
        .custom-marker {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 18px;
            border: 4px solid white;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
        }
        
        /* Marcador de veh√≠culo tipo flecha/moto */
        .vehicle-marker {
            width: 70px;
            height: 70px;
            display: flex;
            align-items: center;
            justify-content: center;
            filter: drop-shadow(0 6px 12px rgba(0,0,0,0.6));
        }
        .vehicle-icon-svg {
            width: 70px;
            height: 70px;
        }
        
        .user-marker {
            width: 28px;
            height: 28px;
            background: #3b82f6;
            border: 4px solid white;
            border-radius: 50%;
            box-shadow: 0 0 20px rgba(59, 130, 246, 0.8);
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0%, 100% { box-shadow: 0 0 20px rgba(59, 130, 246, 0.8); }
            50% { box-shadow: 0 0 40px rgba(59, 130, 246, 1); }
        }
        
        /* Cartel grande de giro tipo Waze - OPTIMIZADO M√ìVIL */
        .turn-billboard {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            z-index: 2000;
            background: linear-gradient(135deg, #1f2937 0%, #111827 100%);
            border: 5px solid #f97316;
            border-radius: 20px;
            padding: 20px 30px;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0,0,0,0.9);
            transition: transform 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            width: 85vw;
            max-width: 320px;
        }
        .turn-billboard.show {
            transform: translate(-50%, -50%) scale(1);
        }
        .turn-billboard .turn-arrow {
            font-size: 80px;
            color: #f97316;
            margin-bottom: 10px;
            text-shadow: 0 0 30px rgba(249, 115, 22, 0.8);
            animation: bounce-turn 0.5s ease infinite alternate;
        }
        .turn-billboard .turn-text {
            font-size: 22px;
            font-weight: bold;
            color: white;
            margin-bottom: 8px;
        }
        .turn-billboard .turn-distance {
            font-size: 42px;
            font-weight: bold;
            color: #fbbf24;
        }
        .turn-billboard .turn-street {
            font-size: 14px;
            color: #9ca3af;
            margin-top: 8px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        @keyframes bounce-turn {
            from { transform: scale(1); }
            to { transform: scale(1.1); }
        }
        
        /* MEN√ö M√ìVIL OPTIMIZADO - COMPACTO */
        .menu-panel {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            z-index: 1000;
            background: rgba(17, 24, 39, 0.98);
            backdrop-filter: blur(12px);
            border-radius: 20px 20px 0 0;
            padding: 8px 12px 16px;
            padding-bottom: max(16px, env(safe-area-inset-bottom));
            border-top: 3px solid #f97316;
            box-shadow: 0 -10px 40px rgba(0,0,0,0.7);
            transition: transform 0.3s ease;
        }
        .menu-panel.collapsed {
            transform: translateY(calc(100% - 50px));
        }
        .menu-handle {
            width: 40px;
            height: 4px;
            background: #4b5563;
            border-radius: 2px;
            margin: 0 auto 8px;
        }
        
        /* NAVEGACI√ìN M√ìVIL */
        .nav-panel {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 1001;
            background: linear-gradient(180deg, rgba(17, 24, 39, 0.98) 0%, rgba(17, 24, 39, 0.95) 100%);
            backdrop-filter: blur(12px);
            padding: 12px 16px;
            padding-top: max(12px, env(safe-area-inset-top));
            border-bottom: 3px solid #f97316;
        }
        .nav-bottom {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            z-index: 1001;
            background: rgba(17, 24, 39, 0.98);
            backdrop-filter: blur(12px);
            padding: 12px 16px;
            padding-bottom: max(16px, env(safe-area-inset-bottom));
            border-top: 2px solid #374151;
        }
        .turn-icon {
            width: 56px;
            height: 56px;
            min-width: 56px;
            background: linear-gradient(135deg, #f97316, #ea580c);
            border-radius: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 26px;
            color: white;
            box-shadow: 0 4px 15px rgba(249, 115, 22, 0.4);
        }
        .speed-display {
            width: 70px;
            height: 70px;
            min-width: 70px;
            background: #1f2937;
            border: 3px solid #f97316;
            border-radius: 50%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        .progress-bar {
            height: 8px;
            background: #374151;
            border-radius: 4px;
            overflow: hidden;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #f97316, #fbbf24);
            transition: width 0.5s ease;
        }
        
        /* B√öSQUEDA M√ìVIL */
        .search-container {
            position: relative;
        }
        .search-results {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: #1f2937;
            border: 2px solid #f97316;
            border-radius: 12px;
            margin-top: 6px;
            max-height: 180px;
            overflow-y: auto;
            z-index: 1002;
            display: none;
        }
        .search-results.show {
            display: block;
        }
        .search-result-item {
            padding: 14px 16px;
            cursor: pointer;
            border-bottom: 1px solid #374151;
            font-size: 15px;
            display: flex;
            align-items: flex-start;
            gap: 12px;
            -webkit-tap-highlight-color: rgba(249, 115, 22, 0.3);
        }
        .search-result-item:last-child {
            border-bottom: none;
        }
        .search-result-item:active {
            background: #374151;
        }
        .search-result-item i {
            color: #f97316;
            margin-top: 3px;
            font-size: 18px;
        }
        .search-input {
            width: 100%;
            background: #111827;
            border: 2px solid #374151;
            border-radius: 10px;
            padding: 10px 32px;
            color: white;
            font-size: 14px;
            transition: all 0.2s;
            -webkit-appearance: none;
        }
        .search-input:focus {
            outline: none;
            border-color: #f97316;
            box-shadow: 0 0 10px rgba(249, 115, 22, 0.3);
        }
        .search-input::placeholder {
            color: #6b7280;
        }
        .search-icon {
            position: absolute;
            left: 10px;
            top: 50%;
            transform: translateY(-50%);
            pointer-events: none;
            font-size: 12px;
        }
        .search-clear {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            color: #9ca3af;
            cursor: pointer;
            padding: 4px;
            font-size: 14px;
        }
        .search-clear:active {
            color: white;
        }
        .search-loading {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            color: #f97316;
            font-size: 18px;
        }
        
        /* BOTONES M√ìVIL - COMPACTOS */
        .btn-mobile {
            min-height: 40px;
            font-size: 13px;
            font-weight: 600;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            transition: all 0.15s;
            -webkit-tap-highlight-color: transparent;
        }
        .btn-mobile:active {
            transform: scale(0.97);
            opacity: 0.9;
        }
        .btn-primary {
            background: linear-gradient(135deg, #f59e0b, #d97706);
            color: #111827;
            box-shadow: 0 2px 10px rgba(245, 158, 11, 0.4);
        }
        .btn-success {
            background: linear-gradient(135deg, #22c55e, #16a34a);
            color: white;
            box-shadow: 0 2px 10px rgba(34, 197, 94, 0.4);
        }
        .btn-danger {
            background: linear-gradient(135deg, #ef4444, #dc2626);
            color: white;
        }
        .btn-secondary {
            background: #374151;
            color: white;
        }
        
        /* FAB BUTTONS */
        .fab-container {
            position: fixed;
            right: 12px;
            bottom: 220px;
            z-index: 999;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .fab {
            width: 44px;
            height: 44px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.4);
            -webkit-tap-highlight-color: transparent;
        }
        .fab:active {
            transform: scale(0.93);
        }
        
        /* INFO CARDS */
        .info-card {
            background: #1f2937;
            border-radius: 14px;
            padding: 12px;
            text-align: center;
        }
        .info-card i {
            font-size: 20px;
            color: #f97316;
            margin-bottom: 4px;
        }
        .info-card .value {
            font-size: 18px;
            font-weight: bold;
        }
        .info-card .label {
            font-size: 11px;
            color: #9ca3af;
            text-transform: uppercase;
        }
        
        /* NOTIFICATION TOAST */
        .notification-toast {
            position: fixed;
            bottom: 100px;
            left: 16px;
            right: 16px;
            background: #1f2937;
            border: 2px solid #f97316;
            color: white;
            padding: 16px;
            border-radius: 14px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            z-index: 3000;
            text-align: center;
            font-size: 15px;
            font-weight: 500;
        }
        
        /* Esconder scrollbar pero permitir scroll */
        .menu-panel::-webkit-scrollbar {
            width: 0;
            display: none;
        }
        
        /* Modo oscuro para inputs */
        input, select {
            color-scheme: dark;
        }
    </style>
</head>
<body class="bg-gray-900 text-white m-0 p-0" style="overflow: hidden; position: fixed; width: 100%; height: 100dvh;">
    <!-- Map Container -->
    <div id="map"></div>

    <!-- FAB Buttons (flotantes) -->
    <div class="fab-container" id="fabContainer">
        <button id="btnLocate" class="fab bg-gray-700" title="Mi ubicaci√≥n">
            <i class="fas fa-crosshairs text-orange-400"></i>
        </button>
        <button id="btnZoomIn" class="fab bg-gray-700" title="Zoom +">
            <i class="fas fa-plus text-white"></i>
        </button>
        <button id="btnZoomOut" class="fab bg-gray-700" title="Zoom -">
            <i class="fas fa-minus text-white"></i>
        </button>
    </div>

    <!-- Planning Menu Panel (M√ìVIL - desde abajo) -->
    <div class="menu-panel" id="menuPanel">
        <!-- Handle para arrastrar -->
        <div class="menu-handle" id="menuHandle"></div>
        
        <!-- Header compacto -->
        <div class="flex items-center gap-2 mb-2">
            <i class="fas fa-motorcycle text-2xl text-orange-500"></i>
            <h1 class="text-lg font-bold text-white flex-1">Enduro Route</h1>
            <button id="toggleMenu" class="w-8 h-8 bg-gray-700 rounded-full flex items-center justify-center">
                <i class="fas fa-chevron-down text-gray-300 text-sm"></i>
            </button>
        </div>

        <div id="menuContent">
            <!-- Campos de b√∫squeda en grid -->
            <div class="grid grid-cols-2 gap-2 mb-2">
                <!-- ORIGEN -->
                <div class="search-container">
                    <i class="fas fa-circle text-green-500 search-icon text-xs"></i>
                    <input type="text" id="searchInputA" class="search-input text-sm py-2 pl-8 pr-8" placeholder="Origen..." autocomplete="off">
                    <i class="fas fa-times search-clear" id="clearSearchA" style="display:none;"></i>
                    <i class="fas fa-spinner fa-spin search-loading" id="loadingA" style="display:none;"></i>
                    <div class="search-results" id="resultsA"></div>
                </div>
                <!-- DESTINO -->
                <div class="search-container">
                    <i class="fas fa-flag-checkered text-red-500 search-icon text-xs"></i>
                    <input type="text" id="searchInputB" class="search-input text-sm py-2 pl-8 pr-8" placeholder="Destino..." autocomplete="off">
                    <i class="fas fa-times search-clear" id="clearSearchB" style="display:none;"></i>
                    <i class="fas fa-spinner fa-spin search-loading" id="loadingB" style="display:none;"></i>
                    <div class="search-results" id="resultsB"></div>
                </div>
            </div>

            <!-- Marcar en mapa + Tipo ruta + Mapa en una fila -->
            <div class="grid grid-cols-4 gap-2 mb-2">
                <button id="btnSetA" class="btn-mobile btn-success py-2 text-xs ring-1 ring-white">
                    <i class="fas fa-map-pin"></i> A
                </button>
                <button id="btnSetB" class="btn-mobile btn-danger py-2 text-xs">
                    <i class="fas fa-flag"></i> B
                </button>
                <div class="flex bg-gray-800 rounded-lg p-0.5">
                    <button id="btnOffroad" class="flex-1 py-2 bg-orange-600 rounded text-xs">
                        <i class="fas fa-mountain"></i>
                    </button>
                    <button id="btnMixed" class="flex-1 py-2 rounded text-xs text-gray-400">
                        <i class="fas fa-road"></i>
                    </button>
                </div>
                <select id="mapType" class="bg-gray-800 border border-gray-600 rounded-lg px-1 py-2 text-xs focus:outline-none">
                    <option value="cyclosm">üèçÔ∏è</option>
                    <option value="mtb">üöµ</option>
                    <option value="topo">‚õ∞Ô∏è</option>
                    <option value="satellite">üõ∞Ô∏è</option>
                </select>
            </div>

            <!-- Bot√≥n Calcular -->
            <div class="flex gap-2 mb-2">
                <button id="btnCalculate" class="flex-1 btn-mobile btn-primary py-3">
                    <i class="fas fa-route"></i>
                    Calcular Ruta
                </button>
                <button id="btnClear" class="btn-mobile btn-secondary px-4 py-3">
                    <i class="fas fa-trash"></i>
                </button>
            </div>

            <!-- Route Info - Compacto -->
            <div id="routeInfo" class="hidden">
                <div class="flex items-center gap-2 mb-2 bg-gray-800 rounded-xl p-2">
                    <div class="flex-1 text-center">
                        <div class="text-lg font-bold text-orange-400" id="distance">0 km</div>
                        <div class="text-xs text-gray-400">Distancia</div>
                    </div>
                    <div class="w-px h-8 bg-gray-600"></div>
                    <div class="flex-1 text-center">
                        <div class="text-lg font-bold text-white" id="duration">0 min</div>
                        <div class="text-xs text-gray-400">Tiempo</div>
                    </div>
                    <div class="w-px h-8 bg-gray-600"></div>
                    <div class="flex-1 text-center">
                        <div class="text-lg font-bold text-green-400" id="elevation">0 m</div>
                        <div class="text-xs text-gray-400">Desnivel</div>
                    </div>
                </div>

                <!-- START NAVIGATION BUTTON -->
                <button id="btnStartNav" class="w-full btn-mobile btn-success py-4 text-lg font-bold shadow-2xl">
                    <i class="fas fa-play text-xl"></i>
                    INICIAR NAVEGACI√ìN
                </button>
            </div>
        </div>
    </div>

    <!-- Navigation Mode UI -->
    <div id="navMode" class="hidden">
        <!-- Top Navigation Panel -->
        <div class="nav-panel">
            <div class="flex items-center gap-3">
                <!-- Turn Indicator -->
                <div class="turn-icon" id="turnIcon">
                    <i class="fas fa-arrow-up"></i>
                </div>
                
                <!-- Turn Instructions -->
                <div class="flex-1 min-w-0">
                    <p class="text-2xl font-bold text-orange-400" id="turnDistance">--</p>
                    <p class="text-white font-medium text-base truncate" id="turnInstruction">Calculando ruta...</p>
                    <p class="text-sm text-gray-400 truncate" id="streetName">--</p>
                </div>

                <!-- Close Button -->
                <button id="btnCloseNav" class="w-12 h-12 min-w-12 bg-red-600 active:bg-red-500 rounded-full flex items-center justify-center shadow-lg">
                    <i class="fas fa-times text-xl"></i>
                </button>
            </div>

            <!-- Progress Bar -->
            <div class="progress-bar mt-3">
                <div class="progress-fill" id="progressFill" style="width: 0%"></div>
            </div>
        </div>

        <!-- Bottom Navigation Panel -->
        <div class="nav-bottom">
            <div class="flex items-center justify-between gap-2">
                <!-- Speed Display -->
                <div class="speed-display">
                    <span class="text-2xl font-bold" id="currentSpeed">0</span>
                    <span class="text-xs text-gray-400">km/h</span>
                </div>

                <!-- ETA and Distance -->
                <div class="text-center flex-1">
                    <div class="flex justify-center gap-6">
                        <div>
                            <p class="text-2xl font-bold text-orange-400" id="navETA">--:--</p>
                            <p class="text-xs text-gray-400">Llegada</p>
                        </div>
                        <div>
                            <p class="text-2xl font-bold text-white" id="navRemaining">-- km</p>
                            <p class="text-xs text-gray-400">Restante</p>
                        </div>
                    </div>
                </div>

                <!-- Center on Me Button -->
                <button id="btnCenterMe" class="w-14 h-14 min-w-14 bg-gray-700 active:bg-gray-600 rounded-full flex items-center justify-center shadow-lg">
                    <i class="fas fa-location-arrow text-xl text-orange-400"></i>
                </button>
            </div>
            
            <!-- Demo Mode Button -->
            <div class="mt-3 flex justify-center">
                <button id="btnDemoMode" class="px-5 py-3 bg-gray-700 active:bg-gray-600 rounded-xl text-sm text-gray-300 flex items-center gap-2 font-medium">
                    <i class="fas fa-play-circle text-orange-400"></i>
                    Modo Demo
                </button>
            </div>

            <!-- Alert Banner -->
            <div id="alertBanner" class="hidden mt-3 bg-gradient-to-r from-orange-600 to-amber-500 rounded-xl p-4 flex items-center gap-3 animate-pulse">
                <i class="fas fa-exclamation-triangle text-2xl"></i>
                <span class="font-bold text-base" id="alertText">¬°Prep√°rate para girar!</span>
            </div>
        </div>
    </div>

    <!-- Turn Billboard (Cartel grande de giro tipo Waze) -->
    <div id="turnBillboard" class="turn-billboard">
        <div class="turn-arrow" id="billboardArrow">
            <i class="fas fa-arrow-left"></i>
        </div>
        <div class="turn-text" id="billboardText">Gira a la izquierda</div>
        <div class="turn-distance" id="billboardDistance">50 m</div>
        <div class="turn-street" id="billboardStreet">hacia Camino del Monte</div>
    </div>

    <!-- Loading Overlay -->
    <div id="loading" class="hidden fixed inset-0 bg-gray-900/80 z-[2000] flex items-center justify-center">
        <div class="text-center">
            <i class="fas fa-motorcycle text-6xl text-orange-500 animate-bounce mb-4"></i>
            <p class="text-xl font-bold" id="loadingText">Buscando caminos de tierra...</p>
            <p class="text-gray-400" id="loadingSubtext">Usando BRouter MTB - Evita asfalto</p>
        </div>
    </div>

    <script>
        // Initialize map
        const map = L.map('map', { zoomControl: false }).setView([40.4168, -3.7038], 6);
        L.control.zoom({ position: 'bottomright' }).addTo(map);

        // Map layers - Los mejores mapas para off-road y enduro
        const mapLayers = {
            // CyclOSM - EL MEJOR para caminos de tierra, pistas forestales, senderos
            cyclosm: L.tileLayer('https://{s}.tile-cyclosm.openstreetmap.fr/cyclosm/{z}/{x}/{y}.png', {
                attribution: '¬© CyclOSM | OpenStreetMap',
                maxZoom: 20
            }),
            // OpenTopoMap - Topogr√°fico con curvas de nivel
            topo: L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
                attribution: '¬© OpenTopoMap',
                maxZoom: 17
            }),
            // MTB Map - Espec√≠fico para mountain bike y off-road
            mtb: L.tileLayer('https://tile.mtbmap.cz/mtbmap_tiles/{z}/{x}/{y}.png', {
                attribution: '¬© MTBMap.cz | OpenStreetMap',
                maxZoom: 18
            }),
            // Sat√©lite con etiquetas
            satellite: L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                attribution: '¬© Esri',
                maxZoom: 19
            }),
            // H√≠brido (sat√©lite + caminos)
            hybrid: L.layerGroup([
                L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                    attribution: '¬© Esri',
                    maxZoom: 19
                }),
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '¬© OpenStreetMap',
                    maxZoom: 19,
                    opacity: 0.4
                })
            ]),
            // OpenStreetMap est√°ndar
            street: L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '¬© OpenStreetMap',
                maxZoom: 19
            })
        };

        // CyclOSM por defecto - el mejor para enduro
        let currentLayer = mapLayers.cyclosm;
        currentLayer.addTo(map);

        // State variables
        let markerA = null;
        let markerB = null;
        let routeLayer = null;
        let currentMode = 'A';
        let routeType = 'offroad';
        let userMarker = null;
        let isNavigating = false;
        let watchId = null;
        let routeCoordinates = [];
        let routeSteps = [];
        let totalDistance = 0;
        let currentStepIndex = 0;
        let lastPosition = null;
        let currentSpeed = 0;

        // Custom icons
        function createMarkerIcon(label, color) {
            return L.divIcon({
                className: 'custom-div-icon',
                html: `<div class="custom-marker" style="background-color: ${color};">${label}</div>`,
                iconSize: [32, 32],
                iconAnchor: [16, 16]
            });
        }

        function createUserIcon(heading = 0) {
            return L.divIcon({
                className: 'user-icon',
                html: `<div class="user-marker"></div>`,
                iconSize: [24, 24],
                iconAnchor: [12, 12]
            });
        }
        
        // Crear icono de veh√≠culo con flecha direccional para navegaci√≥n (tipo moto/GPS)
        function createVehicleIcon(heading = 0) {
            return L.divIcon({
                className: 'vehicle-icon',
                html: `<div class="vehicle-marker">
                    <svg class="vehicle-icon-svg" viewBox="0 0 70 70" style="transform: rotate(${heading}deg);">
                        <!-- Sombra -->
                        <ellipse cx="35" cy="62" rx="14" ry="5" fill="rgba(0,0,0,0.4)"/>
                        <!-- C√≠rculo exterior pulsante -->
                        <circle cx="35" cy="35" r="32" fill="rgba(59, 130, 246, 0.2)" class="pulse-ring"/>
                        <!-- Cuerpo principal (flecha/moto) -->
                        <path d="M35 8 L52 55 L35 45 L18 55 Z" fill="#3b82f6" stroke="#1d4ed8" stroke-width="3"/>
                        <!-- Brillo -->
                        <path d="M35 14 L45 48 L35 40 Z" fill="#60a5fa" opacity="0.6"/>
                        <!-- Punto central -->
                        <circle cx="35" cy="32" r="7" fill="white" stroke="#3b82f6" stroke-width="2"/>
                    </svg>
                </div>`,
                iconSize: [70, 70],
                iconAnchor: [35, 35]
            });
        }
        
        // Variables para la navegaci√≥n avanzada
        let currentHeading = 0;
        let lastHeading = 0;
        let mapRotation = 0;
        let vehicleMarker = null;
        let billboardTimeout = null;

        // Event Listeners
        document.getElementById('mapType').addEventListener('change', function(e) {
            // Remover capa actual (puede ser layer o layerGroup)
            if (currentLayer.eachLayer) {
                currentLayer.eachLayer(layer => map.removeLayer(layer));
            } else {
                map.removeLayer(currentLayer);
            }
            currentLayer = mapLayers[e.target.value];
            currentLayer.addTo(map);
        });

        // Toggle menu (collapse/expand)
        const menuPanel = document.getElementById('menuPanel');
        const toggleMenuBtn = document.getElementById('toggleMenu');
        const menuHandle = document.getElementById('menuHandle');
        
        function toggleMenu() {
            const content = document.getElementById('menuContent');
            const icon = toggleMenuBtn.querySelector('i');
            menuPanel.classList.toggle('collapsed');
            content.classList.toggle('hidden');
            icon.classList.toggle('fa-chevron-up');
            icon.classList.toggle('fa-chevron-down');
        }
        
        toggleMenuBtn.addEventListener('click', toggleMenu);
        menuHandle.addEventListener('click', toggleMenu);
        
        // Zoom buttons
        document.getElementById('btnZoomIn').addEventListener('click', () => map.zoomIn());
        document.getElementById('btnZoomOut').addEventListener('click', () => map.zoomOut());

        document.getElementById('btnSetA').addEventListener('click', () => {
            currentMode = 'A';
            updateButtonStyles();
        });

        document.getElementById('btnSetB').addEventListener('click', () => {
            currentMode = 'B';
            updateButtonStyles();
        });

        document.getElementById('btnOffroad').addEventListener('click', () => {
            routeType = 'offroad';
            updateRouteTypeButtons();
        });

        document.getElementById('btnMixed').addEventListener('click', () => {
            routeType = 'mixed';
            updateRouteTypeButtons();
        });

        document.getElementById('btnCalculate').addEventListener('click', calculateRoute);
        document.getElementById('btnClear').addEventListener('click', clearAll);

        document.getElementById('btnStartNav').addEventListener('click', startNavigation);
        document.getElementById('btnCloseNav').addEventListener('click', stopNavigation);
        document.getElementById('btnCenterMe').addEventListener('click', centerOnUser);
        document.getElementById('btnDemoMode').addEventListener('click', () => {
            showNotification('üéÆ Modo Demo activado - Simulando recorrido');
            simulateNavigation();
        });

        function updateButtonStyles() {
            const btnA = document.getElementById('btnSetA');
            const btnB = document.getElementById('btnSetB');
            
            if (currentMode === 'A') {
                btnA.classList.add('ring-2', 'ring-white', 'ring-offset-2', 'ring-offset-gray-900');
                btnB.classList.remove('ring-2', 'ring-white', 'ring-offset-2', 'ring-offset-gray-900');
            } else {
                btnB.classList.add('ring-2', 'ring-white', 'ring-offset-2', 'ring-offset-gray-900');
                btnA.classList.remove('ring-2', 'ring-white', 'ring-offset-2', 'ring-offset-gray-900');
            }
        }

        function updateRouteTypeButtons() {
            const btnOffroad = document.getElementById('btnOffroad');
            const btnMixed = document.getElementById('btnMixed');
            
            if (routeType === 'offroad') {
                btnOffroad.classList.add('bg-orange-600');
                btnOffroad.classList.remove('hover:bg-gray-700');
                btnMixed.classList.remove('bg-orange-600');
                btnMixed.classList.add('hover:bg-gray-700');
            } else {
                btnMixed.classList.add('bg-orange-600');
                btnMixed.classList.remove('hover:bg-gray-700');
                btnOffroad.classList.remove('bg-orange-600');
                btnOffroad.classList.add('hover:bg-gray-700');
            }
        }

        // Map click handler
        map.on('click', function(e) {
            if (isNavigating) return;
            
            const latlng = e.latlng;
            
            if (currentMode === 'A') {
                if (markerA) map.removeLayer(markerA);
                markerA = L.marker(latlng, {
                    icon: createMarkerIcon('A', '#22c55e'),
                    draggable: true
                }).addTo(map);
                markerA.bindPopup('<b>Punto de Inicio</b>').openPopup();
                
                // Update search input and reverse geocode
                reverseGeocode(latlng, 'A');
                
                currentMode = 'B';
                updateButtonStyles();
            } else {
                if (markerB) map.removeLayer(markerB);
                markerB = L.marker(latlng, {
                    icon: createMarkerIcon('B', '#ef4444'),
                    draggable: true
                }).addTo(map);
                markerB.bindPopup('<b>Punto de Destino</b>').openPopup();
                
                // Update search input and reverse geocode
                reverseGeocode(latlng, 'B');
                
                currentMode = 'A';
                updateButtonStyles();
            }
        });
        
        // Reverse geocode to get address from coordinates
        async function reverseGeocode(latlng, point) {
            const input = point === 'A' ? searchInputA : searchInputB;
            const clearBtn = point === 'A' ? clearSearchA : clearSearchB;
            
            input.value = 'üìç Cargando direcci√≥n...';
            clearBtn.style.display = 'block';
            
            try {
                const response = await fetch(
                    `https://nominatim.openstreetmap.org/reverse?format=json&lat=${latlng.lat}&lon=${latlng.lng}&addressdetails=1`,
                    { headers: { 'Accept-Language': 'es' } }
                );
                
                const data = await response.json();
                
                if (data && data.display_name) {
                    const shortName = data.address?.road || 
                                     data.address?.hamlet || 
                                     data.address?.village || 
                                     data.address?.town || 
                                     data.address?.city ||
                                     data.display_name.split(',')[0];
                    input.value = shortName;
                } else {
                    input.value = `üìç ${latlng.lat.toFixed(4)}, ${latlng.lng.toFixed(4)}`;
                }
            } catch (error) {
                input.value = `üìç ${latlng.lat.toFixed(4)}, ${latlng.lng.toFixed(4)}`;
            }
        }

        // Variables para rutas alternativas
        let allRoutes = [];
        let currentRouteIndex = 0;
        let lastRouteRequest = null;

        // Calculate route
        async function calculateRoute() {
            if (!markerA || !markerB) {
                showNotification('‚ö†Ô∏è Marca ambos puntos (A y B) en el mapa');
                return;
            }

            document.getElementById('loading').classList.remove('hidden');
            
            // Actualizar texto de carga seg√∫n modo
            if (routeType === 'offroad') {
                document.getElementById('loadingText').textContent = 'Buscando caminos de tierra...';
                document.getElementById('loadingSubtext').textContent = 'Usando BRouter MTB - Evita asfalto';
            } else {
                document.getElementById('loadingText').textContent = 'Calculando ruta mixta...';
                document.getElementById('loadingSubtext').textContent = 'Puede incluir carreteras asfaltadas';
            }

            const startCoords = markerA.getLatLng();
            const endCoords = markerB.getLatLng();
            const requestKey = `${startCoords.lat},${startCoords.lng}-${endCoords.lat},${endCoords.lng}-${routeType}`;
            
            // Si es la misma ruta, mostrar la siguiente alternativa
            if (lastRouteRequest === requestKey && allRoutes.length > 1) {
                currentRouteIndex = (currentRouteIndex + 1) % allRoutes.length;
                displayRoute(allRoutes[currentRouteIndex], currentRouteIndex + 1, allRoutes.length);
                document.getElementById('loading').classList.add('hidden');
                return;
            }
            
            // Nueva b√∫squeda de rutas
            lastRouteRequest = requestKey;
            allRoutes = [];
            currentRouteIndex = 0;
            
            try {
                if (routeType === 'offroad') {
                    // Usar BRouter con perfil MTB para evitar asfalto
                    await calculateOffroadRoute(startCoords, endCoords);
                } else {
                    // Modo mixto: usar OSRM normal
                    await calculateMixedRoute(startCoords, endCoords);
                }
            } catch (error) {
                console.error('Error:', error);
                showNotification('‚ö†Ô∏è Error al calcular ruta. Int√©ntalo de nuevo.');
            }

            document.getElementById('loading').classList.add('hidden');
        }
        
        // Calcular ruta OFF-ROAD usando BRouter (evita asfalto)
        async function calculateOffroadRoute(startCoords, endCoords) {
            // BRouter profiles para off-road: mtb, trekking, hiking
            const profiles = ['mtb', 'trekking', 'hiking'];
            
            for (const profile of profiles) {
                try {
                    // BRouter API
                    const brouterUrl = `https://brouter.de/brouter?lonlats=${startCoords.lng},${startCoords.lat}|${endCoords.lng},${endCoords.lat}&profile=${profile}&alternativeidx=0&format=geojson`;
                    
                    const response = await fetch(brouterUrl);
                    
                    if (response.ok) {
                        const data = await response.json();
                        
                        if (data.features && data.features.length > 0) {
                            const feature = data.features[0];
                            const coords = feature.geometry.coordinates;
                            const properties = feature.properties;
                            
                            // Convertir a formato compatible
                            const route = {
                                geometry: feature.geometry,
                                distance: properties['track-length'] || 0,
                                duration: properties['total-time'] || 0,
                                ascend: properties['filtered ascend'] || 0,
                                descend: properties['filtered descend'] || 0,
                                profile: profile,
                                legs: [{
                                    steps: generateStepsFromCoords(coords, properties.messages || [])
                                }]
                            };
                            
                            allRoutes.push(route);
                        }
                    }
                } catch (e) {
                    console.log(`Error con perfil ${profile}:`, e);
                }
            }
            
            // Tambi√©n intentar rutas alternativas con waypoints
            if (allRoutes.length < 3) {
                try {
                    const extraRoutes = await generateOffroadAlternatives(startCoords, endCoords);
                    allRoutes = [...allRoutes, ...extraRoutes];
                } catch (e) {
                    console.log('Error generando alternativas:', e);
                }
            }
            
            if (allRoutes.length > 0) {
                displayRoute(allRoutes[0], 1, allRoutes.length);
                showNotification(`üèîÔ∏è Ruta OFF-ROAD encontrada (${allRoutes[0].profile || 'mtb'})`);
            } else {
                // Fallback a OSRM si BRouter falla
                showNotification('‚ö†Ô∏è BRouter no disponible, usando ruta mixta...');
                await calculateMixedRoute(startCoords, endCoords);
            }
        }
        
        // Generar steps de navegaci√≥n desde coordenadas
        function generateStepsFromCoords(coords, messages) {
            const steps = [];
            
            // Crear un step por cada mensaje de BRouter o cada N puntos
            if (messages && messages.length > 0) {
                messages.forEach((msg, idx) => {
                    if (msg[0] !== undefined && msg[1] !== undefined) {
                        steps.push({
                            maneuver: {
                                type: idx === 0 ? 'depart' : (idx === messages.length - 1 ? 'arrive' : 'turn'),
                                location: [coords[Math.min(idx * 10, coords.length - 1)][0], coords[Math.min(idx * 10, coords.length - 1)][1]],
                                modifier: msg[2] || 'straight'
                            },
                            name: msg[3] || 'Camino',
                            distance: msg[1] || 0
                        });
                    }
                });
            }
            
            // Si no hay mensajes, crear steps b√°sicos
            if (steps.length === 0) {
                const step = Math.floor(coords.length / 10) || 1;
                for (let i = 0; i < coords.length; i += step) {
                    const coord = coords[i];
                    steps.push({
                        maneuver: {
                            type: i === 0 ? 'depart' : (i >= coords.length - step ? 'arrive' : 'continue'),
                            location: [coord[0], coord[1]],
                            modifier: 'straight'
                        },
                        name: 'Camino de tierra',
                        distance: 100
                    });
                }
            }
            
            return steps;
        }
        
        // Generar alternativas off-road con waypoints
        async function generateOffroadAlternatives(start, end) {
            const alternatives = [];
            const midLat = (start.lat + end.lat) / 2;
            const midLng = (start.lng + end.lng) / 2;
            const distance = start.distanceTo(end);
            const offset = distance / 111000 * 0.1; // 10% de la distancia
            
            const offsets = [
                { lat: offset, lng: 0 },
                { lat: -offset, lng: 0 },
                { lat: 0, lng: offset },
                { lat: 0, lng: -offset }
            ];
            
            for (const off of offsets) {
                try {
                    const waypoint = {
                        lat: midLat + off.lat,
                        lng: midLng + off.lng
                    };
                    
                    const brouterUrl = `https://brouter.de/brouter?lonlats=${start.lng},${start.lat}|${waypoint.lng},${waypoint.lat}|${end.lng},${end.lat}&profile=mtb&alternativeidx=0&format=geojson`;
                    
                    const response = await fetch(brouterUrl);
                    
                    if (response.ok) {
                        const data = await response.json();
                        if (data.features && data.features.length > 0) {
                            const feature = data.features[0];
                            const properties = feature.properties;
                            
                            const route = {
                                geometry: feature.geometry,
                                distance: properties['track-length'] || 0,
                                duration: properties['total-time'] || 0,
                                ascend: properties['filtered ascend'] || 0,
                                profile: 'mtb-alt',
                                legs: [{
                                    steps: generateStepsFromCoords(feature.geometry.coordinates, properties.messages || [])
                                }]
                            };
                            
                            // Solo a√±adir si es diferente
                            const isDifferent = !alternatives.some(r => 
                                Math.abs(r.distance - route.distance) < route.distance * 0.05
                            );
                            
                            if (isDifferent) {
                                alternatives.push(route);
                            }
                        }
                    }
                } catch (e) {
                    console.log('Error alternativa off-road:', e);
                }
            }
            
            return alternatives;
        }
        
        // Calcular ruta MIXTA usando OSRM
        async function calculateMixedRoute(startCoords, endCoords) {
            const response = await fetch(
                `https://router.project-osrm.org/route/v1/driving/${startCoords.lng},${startCoords.lat};${endCoords.lng},${endCoords.lat}?overview=full&geometries=geojson&steps=true&alternatives=3`
            );

            if (!response.ok) throw new Error('Error en la API');

            const data = await response.json();
            
            if (data.routes && data.routes.length > 0) {
                allRoutes = data.routes;
                
                // Si solo hay una ruta, intentar generar alternativas con waypoints
                if (allRoutes.length === 1) {
                    const extraRoutes = await generateAlternativeRoutes(startCoords, endCoords);
                    allRoutes = [...allRoutes, ...extraRoutes];
                }
                
                displayRoute(allRoutes[0], 1, allRoutes.length);
            }
        }
        
        // Generar rutas alternativas con waypoints aleatorios
        async function generateAlternativeRoutes(start, end) {
            const alternatives = [];
            const midLat = (start.lat + end.lat) / 2;
            const midLng = (start.lng + end.lng) / 2;
            const distance = start.distanceTo(end);
            const offset = distance / 111000 * 0.15; // 15% de la distancia en grados
            
            // Generar 3 waypoints diferentes (izquierda, derecha, arriba)
            const offsets = [
                { lat: offset, lng: offset },      // Noreste
                { lat: -offset, lng: -offset },    // Suroeste
                { lat: offset, lng: -offset },     // Noroeste
                { lat: -offset, lng: offset },     // Sureste
                { lat: offset * 1.5, lng: 0 },     // Norte
                { lat: -offset * 1.5, lng: 0 },    // Sur
            ];
            
            for (const off of offsets) {
                try {
                    const waypoint = {
                        lat: midLat + off.lat + (Math.random() - 0.5) * offset * 0.5,
                        lng: midLng + off.lng + (Math.random() - 0.5) * offset * 0.5
                    };
                    
                    const response = await fetch(
                        `https://router.project-osrm.org/route/v1/driving/${start.lng},${start.lat};${waypoint.lng},${waypoint.lat};${end.lng},${end.lat}?overview=full&geometries=geojson&steps=true`
                    );
                    
                    if (response.ok) {
                        const data = await response.json();
                        if (data.routes && data.routes.length > 0) {
                            // Solo a√±adir si es significativamente diferente
                            const newDist = data.routes[0].distance;
                            const isDifferent = !alternatives.some(r => 
                                Math.abs(r.distance - newDist) < newDist * 0.05
                            );
                            if (isDifferent && alternatives.length < 5) {
                                alternatives.push(data.routes[0]);
                            }
                        }
                    }
                } catch (e) {
                    console.log('Error generando alternativa:', e);
                }
            }
            
            return alternatives;
        }
        
        // Mostrar una ruta espec√≠fica
        function displayRoute(route, index, total) {
            if (routeLayer) map.removeLayer(routeLayer);
            
            // Store route data for navigation
            routeCoordinates = route.geometry.coordinates.map(c => [c[1], c[0]]);
            routeSteps = route.legs ? route.legs[0].steps : [];
            totalDistance = route.distance;
            
            // Colores diferentes para cada ruta alternativa
            const colors = ['#f97316', '#10b981', '#8b5cf6', '#ec4899', '#06b6d4', '#eab308'];
            const routeColor = colors[(index - 1) % colors.length];
            
            const routeStyle = {
                color: routeColor,
                weight: 6,
                opacity: 0.85,
                dashArray: routeType === 'offroad' ? '12, 8' : null
            };
            
            routeLayer = L.geoJSON(route.geometry, { style: routeStyle }).addTo(map);
            map.fitBounds(routeLayer.getBounds(), { padding: [50, 50] });
            
            const distance = (route.distance / 1000).toFixed(1);
            
            // Calcular duraci√≥n (BRouter da segundos, OSRM tambi√©n)
            let duration;
            if (route.duration) {
                duration = Math.round(route.duration / 60);
            } else {
                // Estimar: 20 km/h en off-road, 40 km/h en mixto
                const avgSpeed = routeType === 'offroad' ? 20 : 40;
                duration = Math.round((route.distance / 1000) / avgSpeed * 60);
            }
            
            // Ajustar tiempo para off-road (m√°s lento)
            const adjustedDuration = routeType === 'offroad' ? Math.round(duration * 1.3) : duration;
            
            // Mostrar desnivel real si est√° disponible (BRouter)
            let elevation;
            if (route.ascend) {
                elevation = Math.round(route.ascend);
            } else {
                elevation = Math.round(parseFloat(distance) * 15); // Estimaci√≥n
            }
            
            document.getElementById('distance').textContent = `${distance} km`;
            document.getElementById('duration').textContent = `${adjustedDuration} min`;
            document.getElementById('elevation').textContent = `‚Üë${elevation} m`;
            document.getElementById('routeInfo').classList.remove('hidden');
            
            // Mostrar el tipo de ruta
            const profileText = route.profile ? ` (${route.profile})` : '';
            
            if (total > 1) {
                showNotification(`üõ§Ô∏è Ruta ${index}/${total}${profileText} - ¬°Pulsa para ver otra!`);
            } else {
                showNotification(`‚úÖ Ruta calculada${profileText} - ¬°Pulsa INICIAR!`);
            }
        }

        // Start Navigation
        function startNavigation() {
            if (routeCoordinates.length === 0) {
                showNotification('‚ö†Ô∏è Primero calcula una ruta');
                return;
            }

            isNavigating = true;
            currentStepIndex = 0;
            
            // Hide planning UI, show navigation UI
            document.getElementById('menuPanel').classList.add('hidden');
            document.getElementById('fabContainer').classList.add('hidden');
            document.getElementById('navMode').classList.remove('hidden');
            
            // Crear marcador de veh√≠culo
            if (vehicleMarker) map.removeLayer(vehicleMarker);
            if (userMarker) map.removeLayer(userMarker);
            
            // Centrar en el inicio de la ruta primero
            const startPoint = L.latLng(routeCoordinates[0][0], routeCoordinates[0][1]);
            
            // Forzar actualizaci√≥n del mapa despu√©s de un peque√±o delay
            setTimeout(() => {
                map.invalidateSize();
                map.setView(startPoint, 15);
                
                // Crear marcador de veh√≠culo en el punto inicial
                vehicleMarker = L.marker(startPoint, {
                    icon: createVehicleIcon(0),
                    zIndexOffset: 1000
                }).addTo(map);
                
                // Forzar recarga de tiles
                setTimeout(() => {
                    map.invalidateSize();
                }, 100);
            }, 50);
            
            // Start watching position
            if ('geolocation' in navigator) {
                watchId = navigator.geolocation.watchPosition(
                    updateNavigation,
                    handleLocationError,
                    {
                        enableHighAccuracy: true,
                        maximumAge: 1000,
                        timeout: 10000
                    }
                );
                
                showNotification('üß≠ Navegaci√≥n iniciada - Esperando GPS...');
                document.getElementById('turnInstruction').textContent = 'Esperando se√±al GPS...';
                document.getElementById('turnDistance').textContent = 'Activa tu GPS';
            } else {
                showNotification('‚ö†Ô∏è Geolocalizaci√≥n no disponible en este dispositivo');
                document.getElementById('turnInstruction').textContent = 'GPS no disponible';
            }
            
            // Activar wake lock para mantener pantalla encendida
            requestWakeLock();
            
            // Initial UI update
            updateNavigationUI();
        }

        // Update navigation based on position
        function updateNavigation(position) {
            const lat = position.coords.latitude;
            const lng = position.coords.longitude;
            const accuracy = position.coords.accuracy;
            const speed = position.coords.speed;
            const heading = position.coords.heading;
            
            // Update speed
            currentSpeed = speed ? Math.round(speed * 3.6) : 0;
            document.getElementById('currentSpeed').textContent = currentSpeed;
            
            // Calcular heading si no est√° disponible
            const userLatLng = L.latLng(lat, lng);
            
            if (lastPosition) {
                const calculatedHeading = calculateBearing(lastPosition, userLatLng);
                if (calculatedHeading !== null && currentSpeed > 2) {
                    currentHeading = heading || calculatedHeading;
                }
            }
            
            // Update or create vehicle marker (flecha direccional)
            if (vehicleMarker) {
                vehicleMarker.setLatLng(userLatLng);
                vehicleMarker.setIcon(createVehicleIcon(currentHeading));
            } else {
                vehicleMarker = L.marker(userLatLng, {
                    icon: createVehicleIcon(currentHeading),
                    zIndexOffset: 1000
                }).addTo(map);
            }
            
            // El icono del veh√≠culo rota seg√∫n heading
            rotateMap(currentHeading);
            
            // Center map on user - zoom moderado para ver bien el mapa
            map.setView(userLatLng, 15);
            
            // Asegurar que el mapa se renderiza correctamente
            if (!map._loaded) {
                map.invalidateSize();
            }
            
            // Calculate distance to destination
            const destLatLng = L.latLng(routeCoordinates[routeCoordinates.length - 1]);
            const remainingDist = userLatLng.distanceTo(destLatLng);
            
            // Update remaining distance
            if (remainingDist > 1000) {
                document.getElementById('navRemaining').textContent = `${(remainingDist/1000).toFixed(1)} km`;
            } else {
                document.getElementById('navRemaining').textContent = `${Math.round(remainingDist)} m`;
            }
            
            // Calculate progress
            const startLatLng = L.latLng(routeCoordinates[0]);
            const totalDist = startLatLng.distanceTo(destLatLng);
            const progress = Math.max(0, Math.min(100, ((totalDist - remainingDist) / totalDist) * 100));
            document.getElementById('progressFill').style.width = `${progress}%`;
            
            // Calculate ETA
            const avgSpeed = currentSpeed > 5 ? currentSpeed : 30; // Default 30 km/h
            const etaMinutes = Math.round((remainingDist / 1000) / avgSpeed * 60);
            const etaTime = new Date(Date.now() + etaMinutes * 60000);
            document.getElementById('navETA').textContent = etaTime.toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit' });
            
            // Find current step
            updateCurrentStep(userLatLng);
            
            // Check if arrived
            if (remainingDist < 50) {
                showNotification('üéâ ¬°Has llegado a tu destino!');
                stopNavigation();
            }
            
            lastPosition = userLatLng;
        }

        // Update current navigation step
        function updateCurrentStep(userLatLng) {
            if (!routeSteps || routeSteps.length === 0) return;
            
            // Find the closest step
            let minDist = Infinity;
            let closestStepIdx = currentStepIndex;
            
            for (let i = currentStepIndex; i < routeSteps.length; i++) {
                const step = routeSteps[i];
                const stepCoord = step.maneuver.location;
                const stepLatLng = L.latLng(stepCoord[1], stepCoord[0]);
                const dist = userLatLng.distanceTo(stepLatLng);
                
                if (dist < minDist) {
                    minDist = dist;
                    closestStepIdx = i;
                }
            }
            
            currentStepIndex = closestStepIdx;
            const currentStep = routeSteps[currentStepIndex];
            
            // Update turn instruction
            const maneuver = currentStep.maneuver;
            const turnType = maneuver.type;
            const modifier = maneuver.modifier || '';
            
            // Get turn icon
            const turnIcon = getTurnIcon(turnType, modifier);
            document.getElementById('turnIcon').innerHTML = `<i class="fas ${turnIcon}"></i>`;
            
            // Distance to next maneuver
            if (minDist > 1000) {
                document.getElementById('turnDistance').textContent = `${(minDist/1000).toFixed(1)} km`;
            } else {
                document.getElementById('turnDistance').textContent = `${Math.round(minDist)} m`;
            }
            
            // Instruction text
            const instruction = getInstructionText(turnType, modifier);
            document.getElementById('turnInstruction').textContent = instruction;
            document.getElementById('streetName').textContent = currentStep.name || 'Camino sin nombre';
            
            // Show alert if close to turn
            const alertBanner = document.getElementById('alertBanner');
            const billboard = document.getElementById('turnBillboard');
            
            if (minDist < 150 && turnType !== 'arrive' && turnType !== 'depart') {
                // Mostrar cartel grande tipo Waze
                showTurnBillboard(turnType, modifier, minDist, currentStep.name);
                alertBanner.classList.remove('hidden');
                document.getElementById('alertText').textContent = `¬°${instruction} en ${Math.round(minDist)}m!`;
            } else if (minDist < 300 && turnType !== 'arrive' && turnType !== 'depart' && (turnType === 'turn' || modifier)) {
                // Pre-aviso a 300m
                showTurnBillboard(turnType, modifier, minDist, currentStep.name);
                alertBanner.classList.add('hidden');
            } else {
                billboard.classList.remove('show');
                alertBanner.classList.add('hidden');
            }
        }
        
        // Mostrar cartel grande de giro tipo Waze
        function showTurnBillboard(turnType, modifier, distance, streetName) {
            const billboard = document.getElementById('turnBillboard');
            const arrow = document.getElementById('billboardArrow');
            const text = document.getElementById('billboardText');
            const distEl = document.getElementById('billboardDistance');
            const street = document.getElementById('billboardStreet');
            
            // Determinar icono y texto
            const iconClass = getTurnIcon(turnType, modifier);
            const instruction = getInstructionText(turnType, modifier);
            
            arrow.innerHTML = `<i class="fas ${iconClass}"></i>`;
            text.textContent = instruction;
            distEl.textContent = distance > 1000 ? `${(distance/1000).toFixed(1)} km` : `${Math.round(distance)} m`;
            street.textContent = streetName ? `hacia ${streetName}` : '';
            
            billboard.classList.add('show');
            
            // Ocultar despu√©s de 3 segundos si la distancia es mayor
            clearTimeout(billboardTimeout);
            if (distance > 200) {
                billboardTimeout = setTimeout(() => {
                    billboard.classList.remove('show');
                }, 3000);
            }
        }
        
        // Calcular bearing entre dos puntos
        function calculateBearing(start, end) {
            if (!start || !end) return 0;
            
            const startLat = start.lat * Math.PI / 180;
            const startLng = start.lng * Math.PI / 180;
            const endLat = end.lat * Math.PI / 180;
            const endLng = end.lng * Math.PI / 180;
            
            const dLng = endLng - startLng;
            
            const x = Math.sin(dLng) * Math.cos(endLat);
            const y = Math.cos(startLat) * Math.sin(endLat) - Math.sin(startLat) * Math.cos(endLat) * Math.cos(dLng);
            
            let bearing = Math.atan2(x, y) * 180 / Math.PI;
            return (bearing + 360) % 360;
        }
        
        // Rotar el mapa seg√∫n heading (desactivado - causa problemas de renderizado)
        function rotateMap(heading) {
            // El icono del veh√≠culo ya rota, no necesitamos rotar el mapa
            mapRotation = heading;
        }

        function getTurnIcon(type, modifier) {
            const icons = {
                'turn-left': 'fa-arrow-left',
                'turn-right': 'fa-arrow-right',
                'sharp left': 'fa-arrow-left',
                'sharp right': 'fa-arrow-right',
                'slight left': 'fa-arrow-up',
                'slight right': 'fa-arrow-up',
                'straight': 'fa-arrow-up',
                'uturn': 'fa-rotate-left',
                'roundabout': 'fa-rotate-right',
                'arrive': 'fa-flag-checkered',
                'depart': 'fa-play'
            };
            
            if (modifier && icons[modifier]) return icons[modifier];
            if (icons[type]) return icons[type];
            return 'fa-arrow-up';
        }

        function getInstructionText(type, modifier) {
            const instructions = {
                'turn': {
                    'left': 'Gira a la izquierda',
                    'right': 'Gira a la derecha',
                    'sharp left': 'Giro cerrado a la izquierda',
                    'sharp right': 'Giro cerrado a la derecha',
                    'slight left': 'Mantente a la izquierda',
                    'slight right': 'Mantente a la derecha',
                    'straight': 'Contin√∫a recto'
                },
                'arrive': 'Llegada al destino',
                'depart': 'Inicia el recorrido',
                'roundabout': 'Entra en la rotonda',
                'fork': modifier?.includes('left') ? 'Toma el desv√≠o izquierdo' : 'Toma el desv√≠o derecho',
                'merge': 'Incorp√≥rate',
                'new name': 'Contin√∫a por',
                'continue': 'Contin√∫a recto'
            };
            
            if (type === 'turn' && modifier) {
                return instructions.turn[modifier] || 'Contin√∫a';
            }
            return instructions[type] || 'Contin√∫a recto';
        }

        function handleLocationError(error) {
            console.error('Location error:', error);
            showNotification('‚ö†Ô∏è Error de GPS. Verifica los permisos de ubicaci√≥n.');
            document.getElementById('turnInstruction').textContent = 'Esperando se√±al GPS...';
            document.getElementById('turnDistance').textContent = '--';
            
            // Reintentar obtener ubicaci√≥n cada 5 segundos
            setTimeout(() => {
                if (isNavigating) {
                    navigator.geolocation.getCurrentPosition(
                        updateNavigation,
                        handleLocationError,
                        { enableHighAccuracy: true, timeout: 10000 }
                    );
                }
            }, 5000);
        }

        // Simulate navigation for demo
        function simulateNavigation() {
            let pointIndex = 0;
            let lastSimCoord = null;
            
            const simulationInterval = setInterval(() => {
                if (!isNavigating || pointIndex >= routeCoordinates.length) {
                    clearInterval(simulationInterval);
                    if (pointIndex >= routeCoordinates.length) {
                        showNotification('üéâ ¬°Has llegado a tu destino!');
                        stopNavigation();
                    }
                    return;
                }
                
                const coord = routeCoordinates[pointIndex];
                const currentLatLng = L.latLng(coord[0], coord[1]);
                
                // Calcular heading basado en el siguiente punto
                let simHeading = 0;
                if (lastSimCoord) {
                    simHeading = calculateBearing(lastSimCoord, currentLatLng);
                } else if (pointIndex + 1 < routeCoordinates.length) {
                    const nextCoord = routeCoordinates[pointIndex + 1];
                    simHeading = calculateBearing(currentLatLng, L.latLng(nextCoord[0], nextCoord[1]));
                }
                
                const fakePosition = {
                    coords: {
                        latitude: coord[0],
                        longitude: coord[1],
                        accuracy: 10,
                        speed: 8 + Math.random() * 10, // 30-65 km/h
                        heading: simHeading
                    }
                };
                
                updateNavigation(fakePosition);
                lastSimCoord = currentLatLng;
                pointIndex += Math.floor(Math.random() * 2) + 1; // Avanzar 1-2 puntos
            }, 800); // M√°s r√°pido para ver mejor la simulaci√≥n
        }

        // Stop navigation
        function stopNavigation() {
            isNavigating = false;
            
            if (watchId) {
                navigator.geolocation.clearWatch(watchId);
                watchId = null;
            }
            
            // Desactivar modo navegaci√≥n
            const mapContainer = document.getElementById('map');
            mapContainer.classList.remove('navigation-mode');
            
            // Ocultar cartel de giro
            document.getElementById('turnBillboard').classList.remove('show');
            
            // Limpiar marcador de veh√≠culo
            if (vehicleMarker) {
                map.removeLayer(vehicleMarker);
                vehicleMarker = null;
            }
            
            // Restaurar zoom
            map.setZoom(14);
            
            // Show planning UI, hide navigation UI
            document.getElementById('menuPanel').classList.remove('hidden');
            document.getElementById('fabContainer').classList.remove('hidden');
            document.getElementById('navMode').classList.add('hidden');
            
            showNotification('üõë Navegaci√≥n finalizada');
        }

        // Center on user
        function centerOnUser() {
            if (vehicleMarker) {
                map.setView(vehicleMarker.getLatLng(), 15);
            } else if (userMarker) {
                map.setView(userMarker.getLatLng(), 15);
            }
        }

        // Update navigation UI
        function updateNavigationUI() {
            if (routeSteps && routeSteps.length > 0) {
                const firstStep = routeSteps[0];
                document.getElementById('turnInstruction').textContent = 'Inicia el recorrido';
                document.getElementById('streetName').textContent = firstStep.name || 'Ruta off-road';
                document.getElementById('navRemaining').textContent = `${(totalDistance/1000).toFixed(1)} km`;
            }
        }

        function showNotification(message) {
            const existing = document.querySelector('.notification-toast');
            if (existing) existing.remove();
            
            const notification = document.createElement('div');
            notification.className = 'notification-toast';
            notification.innerHTML = message;
            document.body.appendChild(notification);
            
            // Animaci√≥n de entrada
            notification.style.opacity = '0';
            notification.style.transform = 'translateY(20px)';
            requestAnimationFrame(() => {
                notification.style.transition = 'all 0.3s ease';
                notification.style.opacity = '1';
                notification.style.transform = 'translateY(0)';
            });
            
            setTimeout(() => {
                notification.style.opacity = '0';
                notification.style.transform = 'translateY(20px)';
                setTimeout(() => notification.remove(), 300);
            }, 3500);
        }

        function clearAll() {
            if (markerA) map.removeLayer(markerA);
            if (markerB) map.removeLayer(markerB);
            if (routeLayer) map.removeLayer(routeLayer);
            if (userMarker) map.removeLayer(userMarker);
            
            markerA = null;
            markerB = null;
            routeLayer = null;
            userMarker = null;
            routeCoordinates = [];
            routeSteps = [];
            currentMode = 'A';
            
            // Limpiar rutas alternativas
            allRoutes = [];
            currentRouteIndex = 0;
            lastRouteRequest = null;
            
            // Clear search inputs
            searchInputA.value = '';
            searchInputB.value = '';
            clearSearchA.style.display = 'none';
            clearSearchB.style.display = 'none';
            loadingA.style.display = 'none';
            loadingB.style.display = 'none';
            resultsA.classList.remove('show');
            resultsB.classList.remove('show');
            
            document.getElementById('routeInfo').classList.add('hidden');
            updateButtonStyles();
            showNotification('üóëÔ∏è Mapa limpiado');
        }

        // ==========================================
        // SEARCH FUNCTIONALITY WITH AUTOCOMPLETE
        // ==========================================
        
        let searchTimeoutA = null;
        let searchTimeoutB = null;
        
        const searchInputA = document.getElementById('searchInputA');
        const searchInputB = document.getElementById('searchInputB');
        const resultsA = document.getElementById('resultsA');
        const resultsB = document.getElementById('resultsB');
        const clearSearchA = document.getElementById('clearSearchA');
        const clearSearchB = document.getElementById('clearSearchB');
        const loadingA = document.getElementById('loadingA');
        const loadingB = document.getElementById('loadingB');
        
        // Search input A
        searchInputA.addEventListener('input', (e) => {
            const query = e.target.value.trim();
            clearTimeout(searchTimeoutA);
            
            if (query.length < 3) {
                resultsA.classList.remove('show');
                clearSearchA.style.display = 'none';
                loadingA.style.display = 'none';
                return;
            }
            
            loadingA.style.display = 'block';
            clearSearchA.style.display = 'none';
            
            searchTimeoutA = setTimeout(() => searchAddress(query, 'A'), 500);
        });
        
        // Search input B
        searchInputB.addEventListener('input', (e) => {
            const query = e.target.value.trim();
            clearTimeout(searchTimeoutB);
            
            if (query.length < 3) {
                resultsB.classList.remove('show');
                clearSearchB.style.display = 'none';
                loadingB.style.display = 'none';
                return;
            }
            
            loadingB.style.display = 'block';
            clearSearchB.style.display = 'none';
            
            searchTimeoutB = setTimeout(() => searchAddress(query, 'B'), 500);
        });
        
        // Clear buttons
        clearSearchA.addEventListener('click', () => {
            searchInputA.value = '';
            resultsA.classList.remove('show');
            clearSearchA.style.display = 'none';
            if (markerA) {
                map.removeLayer(markerA);
                markerA = null;
            }
        });
        
        clearSearchB.addEventListener('click', () => {
            searchInputB.value = '';
            resultsB.classList.remove('show');
            clearSearchB.style.display = 'none';
            if (markerB) {
                map.removeLayer(markerB);
                markerB = null;
            }
        });
        
        // Search address using Nominatim
        async function searchAddress(query, point) {
            const resultsDiv = point === 'A' ? resultsA : resultsB;
            const loadingEl = point === 'A' ? loadingA : loadingB;
            const clearEl = point === 'A' ? clearSearchA : clearSearchB;
            
            try {
                const response = await fetch(
                    `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}&limit=5&addressdetails=1`,
                    {
                        headers: {
                            'Accept-Language': 'es'
                        }
                    }
                );
                
                const data = await response.json();
                
                loadingEl.style.display = 'none';
                clearEl.style.display = 'block';
                
                if (data.length === 0) {
                    resultsDiv.innerHTML = `
                        <div class="search-result-item text-gray-400">
                            <i class="fas fa-info-circle"></i>
                            <span>No se encontraron resultados</span>
                        </div>
                    `;
                    resultsDiv.classList.add('show');
                    return;
                }
                
                resultsDiv.innerHTML = data.map((item, index) => `
                    <div class="search-result-item" data-lat="${item.lat}" data-lon="${item.lon}" data-name="${item.display_name}" data-point="${point}">
                        <i class="fas ${getPlaceIcon(item.type)}"></i>
                        <div>
                            <div class="font-medium text-white">${getShortName(item)}</div>
                            <div class="text-xs text-gray-400 mt-1">${item.display_name}</div>
                        </div>
                    </div>
                `).join('');
                
                resultsDiv.classList.add('show');
                
                // Add click handlers to results
                resultsDiv.querySelectorAll('.search-result-item[data-lat]').forEach(item => {
                    item.addEventListener('click', () => selectSearchResult(item));
                });
                
            } catch (error) {
                console.error('Search error:', error);
                loadingEl.style.display = 'none';
                clearEl.style.display = 'block';
                resultsDiv.innerHTML = `
                    <div class="search-result-item text-red-400">
                        <i class="fas fa-exclamation-circle"></i>
                        <span>Error al buscar. Intenta de nuevo.</span>
                    </div>
                `;
                resultsDiv.classList.add('show');
            }
        }
        
        function getPlaceIcon(type) {
            const icons = {
                'city': 'fa-city',
                'town': 'fa-city',
                'village': 'fa-home',
                'hamlet': 'fa-home',
                'suburb': 'fa-building',
                'neighbourhood': 'fa-building',
                'road': 'fa-road',
                'path': 'fa-hiking',
                'track': 'fa-mountain',
                'footway': 'fa-shoe-prints',
                'cycleway': 'fa-bicycle',
                'peak': 'fa-mountain',
                'hill': 'fa-mountain',
                'forest': 'fa-tree',
                'wood': 'fa-tree',
                'park': 'fa-tree',
                'river': 'fa-water',
                'stream': 'fa-water',
                'lake': 'fa-water'
            };
            return icons[type] || 'fa-map-marker-alt';
        }
        
        function getShortName(item) {
            if (item.address) {
                if (item.address.road) return item.address.road;
                if (item.address.village) return item.address.village;
                if (item.address.town) return item.address.town;
                if (item.address.city) return item.address.city;
                if (item.address.municipality) return item.address.municipality;
            }
            return item.display_name.split(',')[0];
        }
        
        function selectSearchResult(item) {
            const lat = parseFloat(item.dataset.lat);
            const lon = parseFloat(item.dataset.lon);
            const name = item.dataset.name;
            const point = item.dataset.point;
            
            const latlng = L.latLng(lat, lon);
            
            if (point === 'A') {
                if (markerA) map.removeLayer(markerA);
                markerA = L.marker(latlng, {
                    icon: createMarkerIcon('A', '#22c55e'),
                    draggable: true
                }).addTo(map);
                markerA.bindPopup(`<b>Inicio:</b><br>${name.split(',').slice(0,2).join(',')}`);
                
                searchInputA.value = getShortName({display_name: name, address: null});
                resultsA.classList.remove('show');
                clearSearchA.style.display = 'block';
                
                // Auto-focus to point B
                searchInputB.focus();
            } else {
                if (markerB) map.removeLayer(markerB);
                markerB = L.marker(latlng, {
                    icon: createMarkerIcon('B', '#ef4444'),
                    draggable: true
                }).addTo(map);
                markerB.bindPopup(`<b>Destino:</b><br>${name.split(',').slice(0,2).join(',')}`);
                
                searchInputB.value = getShortName({display_name: name, address: null});
                resultsB.classList.remove('show');
                clearSearchB.style.display = 'block';
            }
            
            // Zoom to marker
            map.setView(latlng, 14);
            
            // If both markers exist, fit bounds
            if (markerA && markerB) {
                const group = L.featureGroup([markerA, markerB]);
                map.fitBounds(group.getBounds(), { padding: [50, 50] });
            }
        }
        
        // Close search results when clicking outside
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.search-container')) {
                resultsA.classList.remove('show');
                resultsB.classList.remove('show');
            }
        });
        
        // Use current location as start point
        document.getElementById('btnLocate').addEventListener('click', () => {
            if ('geolocation' in navigator) {
                navigator.geolocation.getCurrentPosition(
                    (position) => {
                        const latlng = L.latLng(position.coords.latitude, position.coords.longitude);
                        
                        if (markerA) map.removeLayer(markerA);
                        markerA = L.marker(latlng, {
                            icon: createMarkerIcon('A', '#22c55e'),
                            draggable: true
                        }).addTo(map);
                        markerA.bindPopup('<b>Tu ubicaci√≥n actual</b>');
                        
                        searchInputA.value = 'üìç Mi ubicaci√≥n actual';
                        clearSearchA.style.display = 'block';
                        
                        map.setView(latlng, 15);
                        showNotification('üìç Ubicaci√≥n establecida como punto de inicio');
                    },
                    (error) => {
                        showNotification('‚ö†Ô∏è No se pudo obtener tu ubicaci√≥n');
                    },
                    { enableHighAccuracy: true }
                );
            }
        });

        // Initialize
        updateButtonStyles();
        updateRouteTypeButtons();

        // Geolocation events
        map.on('locationfound', function(e) {
            if (!isNavigating && !userMarker) {
                userMarker = L.marker(e.latlng, {
                    icon: createUserIcon()
                }).addTo(map);
            }
        });

        map.on('locationerror', function(e) {
            showNotification('üìç No se pudo obtener tu ubicaci√≥n');
        });

        // Register Service Worker for PWA
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./sw.js')
                    .then(registration => {
                        console.log('SW registered:', registration.scope);
                    })
                    .catch(error => {
                        console.log('SW registration failed:', error);
                    });
            });
        }

        // Prevent pull-to-refresh on mobile
        document.body.addEventListener('touchmove', function(e) {
            if (e.target.closest('#map')) return;
            e.preventDefault();
        }, { passive: false });

        // Handle app install prompt
        let deferredPrompt;
        window.addEventListener('beforeinstallprompt', (e) => {
            e.preventDefault();
            deferredPrompt = e;
            // Could show an install button here
        });

        // Wake lock to keep screen on during navigation
        async function requestWakeLock() {
            if ('wakeLock' in navigator && isNavigating) {
                try {
                    await navigator.wakeLock.request('screen');
                    console.log('Wake lock active');
                } catch (err) {
                    console.log('Wake lock error:', err);
                }
            }
        }
    </script>
</body>
</html>

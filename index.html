<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Enduro Route Planner - GPS Off-Road</title>

    <!-- PWA Meta Tags -->
    <meta name="description" content="GPS Off-Road para rutas de enduro - Evita asfalto, busca caminos de tierra">
    <meta name="theme-color" content="#f97316">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="EnduroGPS">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="msapplication-TileColor" content="#111827">
    <meta name="msapplication-tap-highlight" content="no">

    <!-- Manifest -->
    <link rel="manifest" href="./manifest.json">

    <!-- Icons -->
    <link rel="icon" type="image/svg+xml"
        href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 512 512'><rect fill='%23111827' width='512' height='512' rx='64'/><circle cx='256' cy='280' r='140' fill='none' stroke='%23f97316' stroke-width='24'/><circle cx='256' cy='280' r='60' fill='%23f97316'/><polygon points='256,80 276,140 236,140' fill='%23f97316'/></svg>">
    <link rel="apple-touch-icon"
        href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 512 512'><rect fill='%23111827' width='512' height='512' rx='64'/><circle cx='256' cy='280' r='140' fill='none' stroke='%23f97316' stroke-width='24'/><circle cx='256' cy='280' r='60' fill='%23f97316'/><polygon points='256,80 276,140 236,140' fill='%23f97316'/></svg>">

    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
    <style>
        * {
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
        }

        html,
        body {
            touch-action: manipulation;
            overscroll-behavior: none;
        }

        #map {
            height: 100vh;
            height: 100dvh;
            width: 100%;
            position: fixed !important;
            top: 0;
            left: 0;
            z-index: 1;
            perspective: 1000px;
            overflow: hidden;
        }

        /* Enable smooth map rotation and 3D tilt */
        /* Eliminamos las transformaciones conflictivas en el pane interno */



        .leaflet-container {
            font-family: inherit;
            background: #1a1a2e !important;
        }



        .leaflet-tile-pane {
            z-index: 2 !important;
        }

        .leaflet-control-zoom {
            display: none !important;
        }

        .custom-marker {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 18px;
            border: 4px solid white;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
        }

        /* Marcador de veh√≠culo tipo flecha/moto */
        .vehicle-marker {
            width: 70px;
            height: 70px;
            display: flex;
            align-items: center;
            justify-content: center;
            filter: drop-shadow(0 6px 12px rgba(0, 0, 0, 0.6));
        }

        .vehicle-icon-svg {
            width: 70px;
            height: 70px;
        }

        .user-marker {
            width: 28px;
            height: 28px;
            background: #3b82f6;
            border: 4px solid white;
            border-radius: 50%;
            box-shadow: 0 0 20px rgba(59, 130, 246, 0.8);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                box-shadow: 0 0 20px rgba(59, 130, 246, 0.8);
            }

            50% {
                box-shadow: 0 0 40px rgba(59, 130, 246, 1);
            }
        }



        /* MEN√ö M√ìVIL OPTIMIZADO - COMPACTO */
        .menu-panel {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            z-index: 1000;
            background: rgba(17, 24, 39, 0.98);
            backdrop-filter: blur(12px);
            border-radius: 20px 20px 0 0;
            padding: 8px 12px 16px;
            padding-bottom: max(16px, env(safe-area-inset-bottom));
            border-top: 3px solid #f97316;
            box-shadow: 0 -10px 40px rgba(0, 0, 0, 0.7);
            transition: transform 0.3s ease;
        }

        .menu-panel.collapsed {
            transform: translateY(calc(100% - 50px));
        }

        .menu-handle {
            width: 40px;
            height: 4px;
            background: #4b5563;
            border-radius: 2px;
            margin: 0 auto 8px;
        }

        /* NAVEGACI√ìN M√ìVIL */
        .nav-panel {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 1001;
            background: linear-gradient(180deg, rgba(17, 24, 39, 0.98) 0%, rgba(17, 24, 39, 0.95) 100%);
            backdrop-filter: blur(12px);
            padding: 12px 16px;
            padding-top: max(12px, env(safe-area-inset-top));
            border-bottom: 3px solid #f97316;
        }

        .nav-bottom {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            z-index: 1001;
            background: rgba(17, 24, 39, 0.98);
            backdrop-filter: blur(12px);
            padding: 12px 16px;
            padding-bottom: max(16px, env(safe-area-inset-bottom));
            border-top: 2px solid #374151;
        }

        .speed-display {
            width: 70px;
            height: 70px;
            min-width: 70px;
            background: #1f2937;
            border: 3px solid #f97316;
            border-radius: 50%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .progress-bar {
            height: 8px;
            background: #374151;
            border-radius: 4px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #f97316, #fbbf24);
            transition: width 0.5s ease;
        }

        /* B√öSQUEDA M√ìVIL */
        .search-container {
            position: relative;
        }

        .search-results {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: #1f2937;
            border: 2px solid #f97316;
            border-radius: 12px;
            margin-top: 6px;
            max-height: 180px;
            overflow-y: auto;
            z-index: 1002;
            display: none;
        }

        .search-results.show {
            display: block;
        }

        .search-result-item {
            padding: 14px 16px;
            cursor: pointer;
            border-bottom: 1px solid #374151;
            font-size: 15px;
            display: flex;
            align-items: flex-start;
            gap: 12px;
            -webkit-tap-highlight-color: rgba(249, 115, 22, 0.3);
        }

        .search-result-item:last-child {
            border-bottom: none;
        }

        .search-result-item:active {
            background: #374151;
        }

        .search-result-item i {
            color: #f97316;
            margin-top: 3px;
            font-size: 18px;
        }

        .search-input {
            width: 100%;
            background: #111827;
            border: 2px solid #374151;
            border-radius: 10px;
            padding: 10px 32px;
            color: white;
            font-size: 14px;
            transition: all 0.2s;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
        }

        .search-input:focus {
            outline: none;
            border-color: #f97316;
            box-shadow: 0 0 10px rgba(249, 115, 22, 0.3);
        }

        .search-input::placeholder {
            color: #6b7280;
        }

        .search-icon {
            position: absolute;
            left: 10px;
            top: 50%;
            transform: translateY(-50%);
            pointer-events: none;
            font-size: 12px;
        }

        .search-clear {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            color: #9ca3af;
            cursor: pointer;
            padding: 4px;
            font-size: 14px;
        }

        .search-clear:active {
            color: white;
        }

        .search-loading {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            color: #f97316;
            font-size: 18px;
        }

        /* BOTONES M√ìVIL - COMPACTOS */
        .btn-mobile {
            min-height: 40px;
            font-size: 13px;
            font-weight: 600;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            transition: all 0.15s;
            -webkit-tap-highlight-color: transparent;
        }

        .btn-mobile:active {
            transform: scale(0.97);
            opacity: 0.9;
        }

        .btn-primary {
            background: linear-gradient(135deg, #f59e0b, #d97706);
            color: #111827;
            box-shadow: 0 2px 10px rgba(245, 158, 11, 0.4);
        }

        .btn-success {
            background: linear-gradient(135deg, #22c55e, #16a34a);
            color: white;
            box-shadow: 0 2px 10px rgba(34, 197, 94, 0.4);
        }

        .btn-danger {
            background: linear-gradient(135deg, #ef4444, #dc2626);
            color: white;
        }

        .btn-secondary {
            background: #374151;
            color: white;
        }

        /* FAB BUTTONS */
        .fab-container {
            position: fixed;
            right: 12px;
            bottom: 220px;
            z-index: 999;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .fab {
            width: 44px;
            height: 44px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
            -webkit-tap-highlight-color: transparent;
        }

        .fab:active {
            transform: scale(0.93);
        }

        /* INFO CARDS */
        .info-card {
            background: #1f2937;
            border-radius: 14px;
            padding: 12px;
            text-align: center;
        }

        .info-card i {
            font-size: 20px;
            color: #f97316;
            margin-bottom: 4px;
        }

        .info-card .value {
            font-size: 18px;
            font-weight: bold;
        }

        .info-card .label {
            font-size: 11px;
            color: #9ca3af;
            text-transform: uppercase;
        }

        /* NOTIFICATION TOAST */
        .notification-toast {
            position: fixed;
            bottom: 100px;
            left: 16px;
            right: 16px;
            background: #1f2937;
            border: 2px solid #f97316;
            color: white;
            padding: 16px;
            border-radius: 14px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            z-index: 3000;
            text-align: center;
            font-size: 15px;
            font-weight: 500;
        }

        /* Esconder scrollbar pero permitir scroll */
        .menu-panel::-webkit-scrollbar {
            width: 0;
            display: none;
        }

        /* Modo oscuro para inputs */
        input,
        select {
            color-scheme: dark;
        }
    </style>
</head>

<body class="bg-gray-900 text-white m-0 p-0" style="overflow: hidden; position: fixed; width: 100%; height: 100dvh;">
    <!-- Map Container -->
    <div id="map"></div>

    <!-- FAB Buttons (flotantes) -->
    <div class="fab-container" id="fabContainer">
        <button id="btnLocate" class="fab bg-gray-700" title="Mi ubicaci√≥n">
            <i class="fas fa-crosshairs text-orange-400"></i>
        </button>
        <button id="btnZoomIn" class="fab bg-gray-700" title="Zoom +">
            <i class="fas fa-plus text-white"></i>
        </button>
        <button id="btnZoomOut" class="fab bg-gray-700" title="Zoom -">
            <i class="fas fa-minus text-white"></i>
        </button>
    </div>

    <!-- Planning Menu Panel (M√ìVIL - desde abajo) -->
    <div class="menu-panel" id="menuPanel">
        <!-- Handle para arrastrar -->
        <div class="menu-handle" id="menuHandle"></div>

        <!-- Header compacto -->
        <div class="flex items-center gap-2 mb-2">
            <i class="fas fa-motorcycle text-2xl text-orange-500"></i>
            <h1 class="text-lg font-bold text-white flex-1">Enduro Route</h1>
            <button id="toggleMenu" class="w-8 h-8 bg-gray-700 rounded-full flex items-center justify-center">
                <i class="fas fa-chevron-down text-gray-300 text-sm"></i>
            </button>
        </div>

        <div id="menuContent">
            <!-- Campos de b√∫squeda en grid -->
            <div class="grid grid-cols-2 gap-2 mb-2">
                <!-- ORIGEN -->
                <div class="search-container">
                    <i class="fas fa-circle text-green-500 search-icon text-xs"></i>
                    <input type="text" id="searchInputA" class="search-input text-sm py-2 pl-8 pr-8"
                        placeholder="Origen..." autocomplete="off">
                    <i class="fas fa-times search-clear" id="clearSearchA" style="display:none;"></i>
                    <i class="fas fa-spinner fa-spin search-loading" id="loadingA" style="display:none;"></i>
                    <div class="search-results" id="resultsA"></div>
                </div>
                <!-- DESTINO -->
                <div class="search-container">
                    <i class="fas fa-flag-checkered text-red-500 search-icon text-xs"></i>
                    <input type="text" id="searchInputB" class="search-input text-sm py-2 pl-8 pr-8"
                        placeholder="Destino..." autocomplete="off">
                    <i class="fas fa-times search-clear" id="clearSearchB" style="display:none;"></i>
                    <i class="fas fa-spinner fa-spin search-loading" id="loadingB" style="display:none;"></i>
                    <div class="search-results" id="resultsB"></div>
                </div>
            </div>

            <!-- Marcar en mapa + Tipo ruta + Mapa en una fila -->
            <div class="grid grid-cols-4 gap-2 mb-2">
                <button id="btnSetA" class="btn-mobile btn-success py-2 text-xs ring-1 ring-white">
                    <i class="fas fa-map-pin"></i> A
                </button>
                <button id="btnSetB" class="btn-mobile btn-danger py-2 text-xs">
                    <i class="fas fa-flag"></i> B
                </button>
                <div class="flex bg-gray-800 rounded-lg p-0.5">
                    <button id="btnOffroad" class="flex-1 py-2 bg-orange-600 rounded text-xs">
                        <i class="fas fa-mountain"></i>
                    </button>
                    <button id="btnMixed" class="flex-1 py-2 rounded text-xs text-gray-400">
                        <i class="fas fa-road"></i>
                    </button>
                </div>
                <select id="mapType"
                    class="bg-gray-800 border border-gray-600 rounded-lg px-1 py-2 text-xs focus:outline-none">
                    <option value="cyclosm">üèçÔ∏è</option>
                    <option value="mtb">üöµ</option>
                    <option value="topo">‚õ∞Ô∏è</option>
                    <option value="satellite">üõ∞Ô∏è</option>
                </select>
            </div>

            <!-- Bot√≥n Calcular -->
            <div class="flex gap-2 mb-2">
                <button id="btnCalculate" class="flex-1 btn-mobile btn-primary py-3">
                    <i class="fas fa-route"></i>
                    Calcular Ruta
                </button>
                <button id="btnSaveRoute" class="btn-mobile btn-secondary px-3 py-3" title="Guardar ruta">
                    <i class="fas fa-save"></i>
                </button>
                <button id="btnExportGPX" class="btn-mobile btn-secondary px-3 py-3" title="Exportar GPX">
                    <i class="fas fa-download"></i>
                </button>
                <button id="btnClear" class="btn-mobile btn-secondary px-3 py-3">
                    <i class="fas fa-trash"></i>
                </button>
            </div>

            <!-- Rutas Guardadas -->
            <div id="savedRoutesPanel" class="hidden mb-2">
                <div class="bg-gray-800 rounded-xl p-2">
                    <div class="flex items-center justify-between mb-2">
                        <span class="text-sm font-bold text-orange-400"><i class="fas fa-bookmark mr-1"></i> Rutas
                            Guardadas</span>
                        <button id="closeSavedRoutes" class="text-gray-400 text-sm"><i
                                class="fas fa-times"></i></button>
                    </div>
                    <div id="savedRoutesList" class="max-h-32 overflow-y-auto space-y-1"></div>
                </div>
            </div>

            <!-- Route Info - Compacto -->
            <div id="routeInfo" class="hidden">
                <div class="flex items-center gap-2 mb-2 bg-gray-800 rounded-xl p-2">
                    <div class="flex-1 text-center">
                        <div class="text-lg font-bold text-orange-400" id="distance">0 km</div>
                        <div class="text-xs text-gray-400">Distancia</div>
                    </div>
                    <div class="w-px h-8 bg-gray-600"></div>
                    <div class="flex-1 text-center">
                        <div class="text-lg font-bold text-white" id="duration">0 min</div>
                        <div class="text-xs text-gray-400">Tiempo</div>
                    </div>
                    <div class="w-px h-8 bg-gray-600"></div>
                    <div class="flex-1 text-center">
                        <div class="text-lg font-bold text-green-400" id="elevation">0 m</div>
                        <div class="text-xs text-gray-400">Desnivel</div>
                    </div>
                </div>

                <!-- START NAVIGATION BUTTON -->
                <button id="btnStartNav" class="w-full btn-mobile btn-success py-4 text-lg font-bold shadow-2xl">
                    <i class="fas fa-play text-xl"></i>
                    INICIAR NAVEGACI√ìN
                </button>
            </div>
        </div>
    </div>

    <!-- Navigation Mode UI -->
    <div id="navMode" class="hidden">
        <!-- Top Navigation Panel -->
        <div class="nav-panel">
            <div class="flex items-center gap-3 justify-between">
                <div class="flex-1">
                    <p class="text-lg font-bold text-orange-400">Navegaci√≥n activa</p>
                </div>

                <!-- Close Button -->
                <button id="btnCloseNav"
                    class="w-12 h-12 min-w-12 bg-red-600 active:bg-red-500 rounded-full flex items-center justify-center shadow-lg">
                    <i class="fas fa-times text-xl"></i>
                </button>
            </div>

            <!-- Progress Bar -->
            <div class="progress-bar mt-3">
                <div class="progress-fill" id="progressFill" style="width: 0%"></div>
            </div>
        </div>

        <!-- Bottom Navigation Panel -->
        <div class="nav-bottom">
            <div class="flex items-center justify-between gap-2">
                <!-- Speed Display -->
                <div class="speed-display">
                    <span class="text-2xl font-bold" id="currentSpeed">0</span>
                    <span class="text-xs text-gray-400">km/h</span>
                </div>

                <!-- ETA and Distance -->
                <div class="text-center flex-1">
                    <div class="flex justify-center gap-6">
                        <div>
                            <p class="text-2xl font-bold text-orange-400" id="navETA">--:--</p>
                            <p class="text-xs text-gray-400">Llegada</p>
                        </div>
                        <div>
                            <p class="text-2xl font-bold text-white" id="navRemaining">-- km</p>
                            <p class="text-xs text-gray-400">Restante</p>
                        </div>
                    </div>
                </div>

                <!-- Center on Me Button -->
                <button id="btnCenterMe"
                    class="w-14 h-14 min-w-14 bg-gray-700 active:bg-gray-600 rounded-full flex items-center justify-center shadow-lg">
                    <i class="fas fa-location-arrow text-xl text-orange-400"></i>
                </button>


            </div>



        </div>
    </div>

    <!-- Loading Overlay -->
    <div id="loading" class="hidden fixed inset-0 bg-gray-900/80 z-[2000] flex items-center justify-center">
        <div class="text-center">
            <i class="fas fa-motorcycle text-6xl text-orange-500 animate-bounce mb-4"></i>
            <p class="text-xl font-bold" id="loadingText">Buscando caminos de tierra...</p>
            <p class="text-gray-400" id="loadingSubtext">Usando BRouter MTB - Evita asfalto</p>
        </div>
    </div>

    <script>
        // Initialize map
        const map = L.map('map', { zoomControl: false }).setView([40.4168, -3.7038], 6);
        L.control.zoom({ position: 'bottomright' }).addTo(map);

        // Map layers - Los mejores mapas para off-road y enduro
        const mapLayers = {
            // CyclOSM - EL MEJOR para caminos de tierra, pistas forestales, senderos
            cyclosm: L.tileLayer('https://{s}.tile-cyclosm.openstreetmap.fr/cyclosm/{z}/{x}/{y}.png', {
                attribution: '¬© CyclOSM | OpenStreetMap',
                maxZoom: 20
            }),
            // OpenTopoMap - Topogr√°fico con curvas de nivel
            topo: L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
                attribution: '¬© OpenTopoMap',
                maxZoom: 17
            }),
            // MTB Map - Espec√≠fico para mountain bike y off-road
            mtb: L.tileLayer('https://tile.mtbmap.cz/mtbmap_tiles/{z}/{x}/{y}.png', {
                attribution: '¬© MTBMap.cz | OpenStreetMap',
                maxZoom: 18
            }),
            // Sat√©lite con etiquetas
            satellite: L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                attribution: '¬© Esri',
                maxZoom: 19
            }),
            // H√≠brido (sat√©lite + caminos)
            hybrid: L.layerGroup([
                L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                    attribution: '¬© Esri',
                    maxZoom: 19
                }),
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '¬© OpenStreetMap',
                    maxZoom: 19,
                    opacity: 0.4
                })
            ]),
            // OpenStreetMap est√°ndar
            street: L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '¬© OpenStreetMap',
                maxZoom: 19
            })
        };

        // CyclOSM por defecto - el mejor para enduro
        let currentLayer = mapLayers.cyclosm;
        currentLayer.addTo(map);

        // State variables
        let markerA = null;
        let markerB = null;
        let routeLayer = null;
        let currentMode = 'A';
        let routeType = 'offroad';
        let userMarker = null;
        let isNavigating = false;
        let watchId = null;
        let routeCoordinates = [];
        let routeSteps = [];
        let totalDistance = 0;
        let currentStepIndex = 0;
        let lastPosition = null;
        let currentSpeed = 0;

        // Custom icons
        function createMarkerIcon(label, color) {
            return L.divIcon({
                className: 'custom-div-icon',
                html: `<div class="custom-marker" style="background-color: ${color};">${label}</div>`,
                iconSize: [32, 32],
                iconAnchor: [16, 16]
            });
        }

        function createUserIcon(heading = 0) {
            return L.divIcon({
                className: 'user-icon',
                html: `<div class="user-marker"></div>`,
                iconSize: [24, 24],
                iconAnchor: [12, 12]
            });
        }

        // Crear icono de veh√≠culo con flecha direccional para navegaci√≥n (tipo moto/GPS)
        function createVehicleIcon(heading = 0) {
            return L.divIcon({
                className: 'vehicle-icon',
                html: `<div class="vehicle-marker">
                    <svg class="vehicle-icon-svg" viewBox="0 0 70 70" style="transform: rotate(${heading}deg);">
                        <!-- Sombra -->
                        <ellipse cx="35" cy="62" rx="14" ry="5" fill="rgba(0,0,0,0.4)"/>
                        <!-- C√≠rculo exterior pulsante -->
                        <circle cx="35" cy="35" r="32" fill="rgba(59, 130, 246, 0.2)" class="pulse-ring"/>
                        <!-- Cuerpo principal (flecha/moto) -->
                        <path d="M35 8 L52 55 L35 45 L18 55 Z" fill="#3b82f6" stroke="#1d4ed8" stroke-width="3"/>
                        <!-- Brillo -->
                        <path d="M35 14 L45 48 L35 40 Z" fill="#60a5fa" opacity="0.6"/>
                        <!-- Punto central -->
                        <circle cx="35" cy="32" r="7" fill="white" stroke="#3b82f6" stroke-width="2"/>
                    </svg>
                </div>`,
                iconSize: [70, 70],
                iconAnchor: [35, 35]
            });
        }

        // Variables para la navegaci√≥n avanzada
        let currentHeading = 0;
        let lastHeading = 0;
        let mapRotation = 0;
        let cumulativeRotation = 0; // Variable para rotaci√≥n suave continuada
        let vehicleMarker = null;
        let billboardTimeout = null;
        let navigationStartTime = 0; // Para el grace period

        // Funciones para rotaci√≥n del mapa tipo GPS
        function setMapRotation(degrees) {

            // SMART ROTATION: Evitar giro de 360 grados al cruzar el norte (359 -> 0)
            let delta = degrees - lastHeading;

            // Normalizar delta al camino m√°s corto (-180 a 180)
            // Ejemplo: De 350 a 10 deg. Delta = -340. Delta += 360 -> 20. Correcto.
            while (delta < -180) delta += 360;
            while (delta > 180) delta -= 360;

            // Acumular rotaci√≥n
            cumulativeRotation += delta;
            lastHeading = degrees;
            mapRotation = degrees; // Guardar heading real

            const mapDiv = document.getElementById('map');

            // APLICAR TRANSFORMACI√ìN AL CONTENEDOR DEL MAPA (NO AL PANE)
            // Usamos cumulativeRotation en lugar de degrees absoluto para evitar saltos
            mapDiv.style.transform = `perspective(1000px) rotateX(60deg) rotateZ(${-cumulativeRotation}deg) scale(1.5)`;
        }

        function calculateDestinationPoint(latlng, heading, distance) {
            const R = 6371e3; // Radio de la Tierra en metros
            const d = distance; // Distancia en metros
            const brng = heading * Math.PI / 180; // Bearing en radianes
            const lat1 = latlng.lat * Math.PI / 180;
            const lon1 = latlng.lng * Math.PI / 180;

            const lat2 = Math.asin(Math.sin(lat1) * Math.cos(d / R) +
                Math.cos(lat1) * Math.sin(d / R) * Math.cos(brng));

            const lon2 = lon1 + Math.atan2(Math.sin(brng) * Math.sin(d / R) * Math.cos(lat1),
                Math.cos(d / R) - Math.sin(lat1) * Math.sin(lat2));

            return L.latLng(lat2 * 180 / Math.PI, lon2 * 180 / Math.PI);
        }

        function enableGPSView() {
            // Activar clase para transiciones
            const mapDiv = document.getElementById('map');
            mapDiv.classList.add('navigating');
            mapDiv.style.transition = 'transform 0.5s cubic-bezier(0.1, 0, 0.3, 1)';

            // CAMBIAR A MODO SAT√âLITE AUTOM√ÅTICAMENTE PARA REALISMO 3D
            if (mapLayers.satellite) {
                // Remover capa actual
                if (currentLayer && map.hasLayer(currentLayer)) {
                    map.removeLayer(currentLayer);
                }
                // A√±adir sat√©lite
                mapLayers.satellite.addTo(map);
                document.getElementById('mapType').value = 'satellite';
            }
        }

        function disableGPSView() {
            // Desactivar rotaci√≥n y volver a norte arriba
            const mapDiv = document.getElementById('map');
            mapDiv.style.transform = '';
            mapDiv.classList.remove('navigating');
            mapRotation = 0;

            // Volver a mapa CyclOSM (mejor para lectura 2D) o el previo
            if (mapLayers.cyclosm) {
                if (mapLayers.satellite && map.hasLayer(mapLayers.satellite)) {
                    map.removeLayer(mapLayers.satellite);
                }
                currentLayer = mapLayers.cyclosm;
                currentLayer.addTo(map);
                document.getElementById('mapType').value = 'cyclosm';
            }

            // Resetear transici√≥n despu√©s
            setTimeout(() => {
                mapDiv.style.transition = '';
                map.invalidateSize(); // Recolocar tiles
            }, 600);
        }

        // Funci√≥n para calcular el bearing entre dos puntos
        function calculateBearing(from, to) {
            const lat1 = from.lat * Math.PI / 180;
            const lat2 = to.lat * Math.PI / 180;
            const dLon = (to.lng - from.lng) * Math.PI / 180;

            const y = Math.sin(dLon) * Math.cos(lat2);
            const x = Math.cos(lat1) * Math.sin(lat2) -
                Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon);

            const bearing = Math.atan2(y, x) * 180 / Math.PI;
            return (bearing + 360) % 360; // Normalizar a 0-360
        }




        // ==========================================
        // GUARDAR Y CARGAR RUTAS
        // ==========================================
        function saveRoute() {
            if (!markerA || !markerB || routeCoordinates.length === 0) {
                showNotification('‚ö†Ô∏è Primero calcula una ruta');
                return;
            }

            const routeName = prompt('Nombre para la ruta:', `Ruta ${new Date().toLocaleDateString('es-ES')}`);
            if (!routeName) return;

            const savedRoutes = JSON.parse(localStorage.getItem('enduroRoutes') || '[]');

            const routeData = {
                id: Date.now(),
                name: routeName,
                date: new Date().toISOString(),
                startName: searchInputA.value || 'Punto A',
                endName: searchInputB.value || 'Punto B',
                startCoords: markerA.getLatLng(),
                endCoords: markerB.getLatLng(),
                coordinates: routeCoordinates,
                distance: totalDistance,
                routeType: routeType
            };

            savedRoutes.unshift(routeData);

            // M√°ximo 20 rutas guardadas
            if (savedRoutes.length > 20) savedRoutes.pop();

            localStorage.setItem('enduroRoutes', JSON.stringify(savedRoutes));
            showNotification(`üíæ Ruta "${routeName}" guardada`);
        }

        function loadSavedRoutes() {
            const savedRoutes = JSON.parse(localStorage.getItem('enduroRoutes') || '[]');
            const panel = document.getElementById('savedRoutesPanel');
            const list = document.getElementById('savedRoutesList');

            if (savedRoutes.length === 0) {
                list.innerHTML = '<p class="text-gray-400 text-xs text-center py-2">No hay rutas guardadas</p>';
            } else {
                list.innerHTML = savedRoutes.map(route => `
                    <div class="flex items-center gap-2 bg-gray-700 rounded-lg p-2">
                        <div class="flex-1 min-w-0">
                            <p class="text-white text-sm font-medium truncate">${route.name}</p>
                            <p class="text-gray-400 text-xs truncate">${route.startName} ‚Üí ${route.endName}</p>
                            <p class="text-gray-500 text-xs">${(route.distance / 1000).toFixed(1)} km</p>
                        </div>
                        <button onclick="loadRoute(${route.id})" class="w-8 h-8 bg-green-600 rounded-full flex items-center justify-center">
                            <i class="fas fa-play text-xs"></i>
                        </button>
                        <button onclick="deleteRoute(${route.id})" class="w-8 h-8 bg-red-600 rounded-full flex items-center justify-center">
                            <i class="fas fa-trash text-xs"></i>
                        </button>
                    </div>
                `).join('');
            }

            panel.classList.toggle('hidden');
        }

        function loadRoute(routeId) {
            const savedRoutes = JSON.parse(localStorage.getItem('enduroRoutes') || '[]');
            const route = savedRoutes.find(r => r.id === routeId);

            if (!route) {
                showNotification('‚ö†Ô∏è Ruta no encontrada');
                return;
            }

            // Limpiar ruta actual
            if (markerA) map.removeLayer(markerA);
            if (markerB) map.removeLayer(markerB);
            if (routeLayer) map.removeLayer(routeLayer);

            // Crear marcadores
            const startLatLng = L.latLng(route.startCoords.lat, route.startCoords.lng);
            const endLatLng = L.latLng(route.endCoords.lat, route.endCoords.lng);

            markerA = L.marker(startLatLng, {
                icon: createMarkerIcon('A', '#22c55e'),
                draggable: true
            }).addTo(map);

            markerB = L.marker(endLatLng, {
                icon: createMarkerIcon('B', '#ef4444'),
                draggable: true
            }).addTo(map);

            // Actualizar inputs
            searchInputA.value = route.startName;
            searchInputB.value = route.endName;
            clearSearchA.style.display = 'block';
            clearSearchB.style.display = 'block';

            // Cargar ruta
            routeCoordinates = route.coordinates;
            totalDistance = route.distance;
            routeType = route.routeType || 'offroad';

            // Dibujar ruta
            const geoJsonCoords = routeCoordinates.map(c => [c[1], c[0]]);
            routeLayer = L.polyline(routeCoordinates, {
                color: '#f97316',
                weight: 6,
                opacity: 0.85,
                dashArray: routeType === 'offroad' ? '12, 8' : null
            }).addTo(map);

            map.fitBounds(routeLayer.getBounds(), { padding: [50, 50] });

            // Mostrar info
            document.getElementById('distance').textContent = `${(totalDistance / 1000).toFixed(1)} km`;
            document.getElementById('routeInfo').classList.remove('hidden');
            document.getElementById('savedRoutesPanel').classList.add('hidden');

            showNotification(`‚úÖ Ruta "${route.name}" cargada`);
        }

        function deleteRoute(routeId) {
            if (!confirm('¬øEliminar esta ruta?')) return;

            let savedRoutes = JSON.parse(localStorage.getItem('enduroRoutes') || '[]');
            savedRoutes = savedRoutes.filter(r => r.id !== routeId);
            localStorage.setItem('enduroRoutes', JSON.stringify(savedRoutes));

            loadSavedRoutes();
            showNotification('üóëÔ∏è Ruta eliminada');
        }

        document.getElementById('btnSaveRoute').addEventListener('click', saveRoute);
        document.getElementById('btnSaveRoute').addEventListener('click', saveRoute);
        document.getElementById('closeSavedRoutes').addEventListener('click', () => {
            document.getElementById('savedRoutesPanel').classList.add('hidden');
        });

        // Long press para ver rutas guardadas
        let saveButtonTimer;
        document.getElementById('btnSaveRoute').addEventListener('touchstart', () => {
            saveButtonTimer = setTimeout(loadSavedRoutes, 500);
        });
        document.getElementById('btnSaveRoute').addEventListener('touchend', () => {
            clearTimeout(saveButtonTimer);
        });
        document.getElementById('btnSaveRoute').addEventListener('click', (e) => {
            if (e.detail === 2) { // Doble click
                loadSavedRoutes();
            }
        });

        // ==========================================
        // EXPORTAR GPX
        // ==========================================
        function exportGPX() {
            if (routeCoordinates.length === 0) {
                showNotification('‚ö†Ô∏è Primero calcula una ruta');
                return;
            }

            const now = new Date().toISOString();
            const routeName = `Enduro_${new Date().toLocaleDateString('es-ES').replace(/\//g, '-')}`;

            let gpx = `<?xml version="1.0" encoding="UTF-8"?>
<gpx version="1.1" creator="Enduro Route Planner"
     xmlns="http://www.topografix.com/GPX/1/1"
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xsi:schemaLocation="http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/1/1/gpx.xsd">
  <metadata>
    <name>${routeName}</name>
    <desc>Ruta off-road generada con Enduro Route Planner</desc>
    <time>${now}</time>
  </metadata>
  <trk>
    <name>${routeName}</name>
    <type>${routeType === 'offroad' ? 'Off-Road' : 'Mixed'}</type>
    <trkseg>
`;

            routeCoordinates.forEach(coord => {
                gpx += `      <trkpt lat="${coord[0]}" lon="${coord[1]}"></trkpt>\n`;
            });

            gpx += `    </trkseg>
  </trk>
`;

            // A√±adir waypoints de inicio y fin
            if (markerA && markerB) {
                const startCoords = markerA.getLatLng();
                const endCoords = markerB.getLatLng();

                gpx += `  <wpt lat="${startCoords.lat}" lon="${startCoords.lng}">
    <name>Inicio</name>
    <desc>${searchInputA.value || 'Punto de inicio'}</desc>
    <sym>Flag, Green</sym>
  </wpt>
  <wpt lat="${endCoords.lat}" lon="${endCoords.lng}">
    <name>Fin</name>
    <desc>${searchInputB.value || 'Punto de destino'}</desc>
    <sym>Flag, Red</sym>
  </wpt>
`;
            }

            gpx += `</gpx>`;

            // Descargar archivo
            const blob = new Blob([gpx], { type: 'application/gpx+xml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${routeName}.gpx`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            showNotification('üì• Archivo GPX descargado');
        }

        document.getElementById('btnExportGPX').addEventListener('click', exportGPX);

        // Event Listeners
        document.getElementById('mapType').addEventListener('change', function (e) {
            // Remover capa actual (puede ser layer o layerGroup)
            if (currentLayer.eachLayer) {
                currentLayer.eachLayer(layer => map.removeLayer(layer));
            } else {
                map.removeLayer(currentLayer);
            }
            currentLayer = mapLayers[e.target.value];
            currentLayer.addTo(map);
        });

        // Toggle menu (collapse/expand)
        const menuPanel = document.getElementById('menuPanel');
        const toggleMenuBtn = document.getElementById('toggleMenu');
        const menuHandle = document.getElementById('menuHandle');

        function toggleMenu() {
            const content = document.getElementById('menuContent');
            const icon = toggleMenuBtn.querySelector('i');
            menuPanel.classList.toggle('collapsed');
            content.classList.toggle('hidden');
            icon.classList.toggle('fa-chevron-up');
            icon.classList.toggle('fa-chevron-down');
        }

        toggleMenuBtn.addEventListener('click', toggleMenu);
        menuHandle.addEventListener('click', toggleMenu);

        // Zoom buttons
        document.getElementById('btnZoomIn').addEventListener('click', () => map.zoomIn());
        document.getElementById('btnZoomOut').addEventListener('click', () => map.zoomOut());

        document.getElementById('btnSetA').addEventListener('click', () => {
            currentMode = 'A';
            updateButtonStyles();
        });

        document.getElementById('btnSetB').addEventListener('click', () => {
            currentMode = 'B';
            updateButtonStyles();
        });

        document.getElementById('btnOffroad').addEventListener('click', () => {
            routeType = 'offroad';
            updateRouteTypeButtons();
        });

        document.getElementById('btnMixed').addEventListener('click', () => {
            routeType = 'mixed';
            updateRouteTypeButtons();
        });

        document.getElementById('btnCalculate').addEventListener('click', calculateRoute);
        document.getElementById('btnClear').addEventListener('click', clearAll);

        document.getElementById('btnStartNav').addEventListener('click', startNavigation);
        document.getElementById('btnCloseNav').addEventListener('click', stopNavigation);
        document.getElementById('btnCenterMe').addEventListener('click', centerOnUser);



        function updateButtonStyles() {
            const btnA = document.getElementById('btnSetA');
            const btnB = document.getElementById('btnSetB');

            if (currentMode === 'A') {
                btnA.classList.add('ring-2', 'ring-white', 'ring-offset-2', 'ring-offset-gray-900');
                btnB.classList.remove('ring-2', 'ring-white', 'ring-offset-2', 'ring-offset-gray-900');
            } else {
                btnB.classList.add('ring-2', 'ring-white', 'ring-offset-2', 'ring-offset-gray-900');
                btnA.classList.remove('ring-2', 'ring-white', 'ring-offset-2', 'ring-offset-gray-900');
            }
        }

        function updateRouteTypeButtons() {
            const btnOffroad = document.getElementById('btnOffroad');
            const btnMixed = document.getElementById('btnMixed');

            if (routeType === 'offroad') {
                btnOffroad.classList.add('bg-orange-600');
                btnOffroad.classList.remove('hover:bg-gray-700');
                btnMixed.classList.remove('bg-orange-600');
                btnMixed.classList.add('hover:bg-gray-700');
            } else {
                btnMixed.classList.add('bg-orange-600');
                btnMixed.classList.remove('hover:bg-gray-700');
                btnOffroad.classList.remove('bg-orange-600');
                btnOffroad.classList.add('hover:bg-gray-700');
            }
        }

        // Map click handler
        map.on('click', function (e) {
            if (isNavigating) return;

            const latlng = e.latlng;

            if (currentMode === 'A') {
                if (markerA) map.removeLayer(markerA);
                markerA = L.marker(latlng, {
                    icon: createMarkerIcon('A', '#22c55e'),
                    draggable: true
                }).addTo(map);
                markerA.bindPopup('<b>Punto de Inicio</b>').openPopup();

                // Update search input and reverse geocode
                reverseGeocode(latlng, 'A');

                currentMode = 'B';
                updateButtonStyles();
            } else {
                if (markerB) map.removeLayer(markerB);
                markerB = L.marker(latlng, {
                    icon: createMarkerIcon('B', '#ef4444'),
                    draggable: true
                }).addTo(map);
                markerB.bindPopup('<b>Punto de Destino</b>').openPopup();

                // Update search input and reverse geocode
                reverseGeocode(latlng, 'B');

                currentMode = 'A';
                updateButtonStyles();
            }
        });

        // Reverse geocode to get address from coordinates
        async function reverseGeocode(latlng, point) {
            const input = point === 'A' ? searchInputA : searchInputB;
            const clearBtn = point === 'A' ? clearSearchA : clearSearchB;

            input.value = 'üìç Cargando direcci√≥n...';
            clearBtn.style.display = 'block';

            try {
                const response = await fetch(
                    `https://nominatim.openstreetmap.org/reverse?format=json&lat=${latlng.lat}&lon=${latlng.lng}&addressdetails=1`,
                    { headers: { 'Accept-Language': 'es' } }
                );

                const data = await response.json();

                if (data && data.display_name) {
                    const shortName = data.address?.road ||
                        data.address?.hamlet ||
                        data.address?.village ||
                        data.address?.town ||
                        data.address?.city ||
                        data.display_name.split(',')[0];
                    input.value = shortName;
                } else {
                    input.value = `üìç ${latlng.lat.toFixed(4)}, ${latlng.lng.toFixed(4)}`;
                }
            } catch (error) {
                input.value = `üìç ${latlng.lat.toFixed(4)}, ${latlng.lng.toFixed(4)}`;
            }
        }

        // Variables para rutas alternativas
        let allRoutes = [];
        let currentRouteIndex = 0;
        let lastRouteRequest = null;

        // ==========================================
        // AUTO-DEMO ROUTE (FALLBACK)
        // ==========================================
        function generateDemoRoute(startCoords, endCoords) {
            console.log('‚ö†Ô∏è Generando ruta de demostraci√≥n (Fallback)');

            // Generar puntos intermedios para hacer una curva
            const lat1 = startCoords.lat;
            const lng1 = startCoords.lng;
            const lat2 = endCoords.lat;
            const lng2 = endCoords.lng;

            const midLat = (lat1 + lat2) / 2;
            const midLng = (lng1 + lng2) / 2;

            // Crear una curva a√±adiendo offset
            const curveOffset = 0.005; // ~500m

            const demoCoordinates = [
                [lat1, lng1],
                [midLat + curveOffset, midLng - curveOffset], // Punto intermedio 1
                [midLat - curveOffset, midLng + curveOffset], // Punto intermedio 2
                [lat2, lng2]
            ];

            // Interpolaci√≥n simple para tener m√°s puntos
            const detailedCoords = [];
            for (let i = 0; i < demoCoordinates.length - 1; i++) {
                const current = demoCoordinates[i];
                const next = demoCoordinates[i + 1];
                const steps = 20; // Puntos por segmento

                for (let j = 0; j < steps; j++) {
                    const t = j / steps;
                    const lat = current[0] + (next[0] - current[0]) * t;
                    const lng = current[1] + (next[1] - current[1]) * t;
                    detailedCoords.push([lat, lng]);
                }
            }
            detailedCoords.push([lat2, lng2]); // A√±adir punto final

            // Estructura de ruta simulada
            const demoRoute = {
                geometry: {
                    coordinates: detailedCoords.map(c => [c[1], c[0]]), // GeoJSON [lng, lat]
                    type: "LineString"
                },
                distance: 2500, // 2.5 km ficticios
                duration: 300,  // 5 min
                profile: 'demo-fallback',
                legs: [{
                    steps: generateStepsFromCoords(detailedCoords.map(c => [c[1], c[0]]), [])
                }]
            };

            allRoutes = [demoRoute];
            displayRoute(demoRoute, 1, 1);

            showNotification('‚ö†Ô∏è Modo Local/Offline: Ruta DEMO generada');
            document.getElementById('loading').classList.add('hidden');
        }

        // Calculate route
        async function calculateRoute() {
            if (!markerA || !markerB) {
                showNotification('‚ö†Ô∏è Marca ambos puntos (A y B) en el mapa');
                return;
            }

            document.getElementById('loading').classList.remove('hidden');

            // Actualizar texto de carga seg√∫n modo
            if (routeType === 'offroad') {
                document.getElementById('loadingText').textContent = 'Buscando caminos de tierra...';
                document.getElementById('loadingSubtext').textContent = 'Usando BRouter MTB - Evita asfalto';
            } else {
                document.getElementById('loadingText').textContent = 'Calculando ruta mixta...';
                document.getElementById('loadingSubtext').textContent = 'Puede incluir carreteras asfaltadas';
            }

            const startCoords = markerA.getLatLng();
            const endCoords = markerB.getLatLng();
            const requestKey = `${startCoords.lat},${startCoords.lng}-${endCoords.lat},${endCoords.lng}-${routeType}`;

            // Si es la misma ruta, mostrar la siguiente alternativa
            if (lastRouteRequest === requestKey && allRoutes.length > 1) {
                currentRouteIndex = (currentRouteIndex + 1) % allRoutes.length;
                displayRoute(allRoutes[currentRouteIndex], currentRouteIndex + 1, allRoutes.length);
                document.getElementById('loading').classList.add('hidden');
                return;
            }

            // Nueva b√∫squeda de rutas
            lastRouteRequest = requestKey;
            allRoutes = [];
            currentRouteIndex = 0;

            try {
                if (routeType === 'offroad') {
                    // Usar BRouter con perfil MTB para evitar asfalto
                    await calculateOffroadRoute(startCoords, endCoords);
                } else {
                    // Modo mixto: usar OSRM normal
                    await calculateMixedRoute(startCoords, endCoords);
                }
            } catch (error) {
                console.error('Error al calcular ruta:', error);

                // FALLBACK AUTOM√ÅTICO PARA PRUEBAS LOCALES
                if (window.location.protocol === 'file:' || error.message.includes('Failed to fetch') || error.name === 'TypeError') {
                    console.warn('‚ö†Ô∏è Fallo en API, activando modo DEMO local');
                    generateDemoRoute(startCoords, endCoords);
                } else {
                    showNotification('‚ö†Ô∏è Error al calcular ruta. Int√©ntalo de nuevo.');
                }
            }

            document.getElementById('loading').classList.add('hidden');
        }

        // Calcular ruta OFF-ROAD usando BRouter (evita asfalto)
        async function calculateOffroadRoute(startCoords, endCoords) {
            // BRouter profiles para off-road: mtb, trekking, hiking
            const profiles = ['mtb', 'trekking', 'hiking'];

            for (const profile of profiles) {
                try {
                    // BRouter API
                    const brouterUrl = `https://brouter.de/brouter?lonlats=${startCoords.lng},${startCoords.lat}|${endCoords.lng},${endCoords.lat}&profile=${profile}&alternativeidx=0&format=geojson`;

                    const response = await fetch(brouterUrl);

                    if (response.ok) {
                        const data = await response.json();

                        if (data.features && data.features.length > 0) {
                            const feature = data.features[0];
                            const coords = feature.geometry.coordinates;
                            const properties = feature.properties;

                            // Convertir a formato compatible
                            const route = {
                                geometry: feature.geometry,
                                distance: properties['track-length'] || 0,
                                duration: properties['total-time'] || 0,
                                ascend: properties['filtered ascend'] || 0,
                                descend: properties['filtered descend'] || 0,
                                profile: profile,
                                legs: [{
                                    steps: generateStepsFromCoords(coords, properties.messages || [])
                                }]
                            };

                            allRoutes.push(route);
                        }
                    }
                } catch (e) {
                    console.log(`Error con perfil ${profile}:`, e);
                }
            }

            // Tambi√©n intentar rutas alternativas con waypoints
            if (allRoutes.length < 3) {
                try {
                    const extraRoutes = await generateOffroadAlternatives(startCoords, endCoords);
                    allRoutes = [...allRoutes, ...extraRoutes];
                } catch (e) {
                    console.log('Error generando alternativas:', e);
                }
            }

            if (allRoutes.length > 0) {
                displayRoute(allRoutes[0], 1, allRoutes.length);
                showNotification(`üèîÔ∏è Ruta OFF-ROAD encontrada (${allRoutes[0].profile || 'mtb'})`);
            } else {
                // Fallback a OSRM si BRouter falla
                showNotification('‚ö†Ô∏è BRouter no disponible, usando ruta mixta...');
                await calculateMixedRoute(startCoords, endCoords);
            }
        }

        // Generar steps de navegaci√≥n desde coordenadas
        function generateStepsFromCoords(coords, messages) {
            const steps = [];

            // Calcular giros basados en cambios de direcci√≥n en las coordenadas
            for (let i = 0; i < coords.length; i++) {
                const coord = coords[i];

                // Calcular direcci√≥n si hay punto anterior y siguiente
                let modifier = 'straight';
                let type = 'continue';

                if (i === 0) {
                    type = 'depart';
                } else if (i === coords.length - 1) {
                    type = 'arrive';
                } else if (i > 0 && i < coords.length - 1) {
                    // Calcular √°ngulo de giro
                    const prev = coords[i - 1];
                    const curr = coords[i];
                    const next = coords[i + 1];

                    const angle1 = Math.atan2(curr[1] - prev[1], curr[0] - prev[0]);
                    const angle2 = Math.atan2(next[1] - curr[1], next[0] - curr[0]);
                    let turn = (angle2 - angle1) * 180 / Math.PI;

                    // Normalizar a -180 a 180
                    while (turn > 180) turn -= 360;
                    while (turn < -180) turn += 360;

                    // Detectar giros significativos (> 30 grados)
                    if (turn > 30 && turn < 150) {
                        type = 'turn';
                        modifier = 'right';
                    } else if (turn < -30 && turn > -150) {
                        type = 'turn';
                        modifier = 'left';
                    } else if (Math.abs(turn) >= 150) {
                        type = 'turn';
                        modifier = turn > 0 ? 'sharp right' : 'sharp left';
                    }
                }

                // Solo a√±adir steps cada ciertos puntos o si hay giro
                const isImportant = type === 'depart' || type === 'arrive' || type === 'turn';
                const isInterval = i % Math.max(1, Math.floor(coords.length / 20)) === 0;

                if (isImportant || isInterval) {
                    steps.push({
                        maneuver: {
                            type: type,
                            location: [coord[0], coord[1]],
                            modifier: modifier
                        },
                        name: 'Camino de tierra',
                        distance: 100
                    });
                }
            }

            console.log('Steps generados:', steps.length, steps.filter(s => s.maneuver.modifier.includes('left') || s.maneuver.modifier.includes('right')).length, 'giros');

            return steps;
        }

        // Generar alternativas off-road con waypoints
        async function generateOffroadAlternatives(start, end) {
            const alternatives = [];
            const midLat = (start.lat + end.lat) / 2;
            const midLng = (start.lng + end.lng) / 2;
            const distance = start.distanceTo(end);
            const offset = distance / 111000 * 0.1; // 10% de la distancia

            const offsets = [
                { lat: offset, lng: 0 },
                { lat: -offset, lng: 0 },
                { lat: 0, lng: offset },
                { lat: 0, lng: -offset }
            ];

            for (const off of offsets) {
                try {
                    const waypoint = {
                        lat: midLat + off.lat,
                        lng: midLng + off.lng
                    };

                    const brouterUrl = `https://brouter.de/brouter?lonlats=${start.lng},${start.lat}|${waypoint.lng},${waypoint.lat}|${end.lng},${end.lat}&profile=mtb&alternativeidx=0&format=geojson`;

                    const response = await fetch(brouterUrl);

                    if (response.ok) {
                        const data = await response.json();
                        if (data.features && data.features.length > 0) {
                            const feature = data.features[0];
                            const properties = feature.properties;

                            const route = {
                                geometry: feature.geometry,
                                distance: properties['track-length'] || 0,
                                duration: properties['total-time'] || 0,
                                ascend: properties['filtered ascend'] || 0,
                                profile: 'mtb-alt',
                                legs: [{
                                    steps: generateStepsFromCoords(feature.geometry.coordinates, properties.messages || [])
                                }]
                            };

                            // Solo a√±adir si es diferente
                            const isDifferent = !alternatives.some(r =>
                                Math.abs(r.distance - route.distance) < route.distance * 0.05
                            );

                            if (isDifferent) {
                                alternatives.push(route);
                            }
                        }
                    }
                } catch (e) {
                    console.log('Error alternativa off-road:', e);
                }
            }

            return alternatives;
        }

        // Calcular ruta MIXTA usando OSRM
        async function calculateMixedRoute(startCoords, endCoords) {
            const response = await fetch(
                `https://router.project-osrm.org/route/v1/driving/${startCoords.lng},${startCoords.lat};${endCoords.lng},${endCoords.lat}?overview=full&geometries=geojson&steps=true&alternatives=3`
            );

            if (!response.ok) throw new Error('Error en la API');

            const data = await response.json();

            if (data.routes && data.routes.length > 0) {
                allRoutes = data.routes;

                // Si solo hay una ruta, intentar generar alternativas con waypoints
                if (allRoutes.length === 1) {
                    const extraRoutes = await generateAlternativeRoutes(startCoords, endCoords);
                    allRoutes = [...allRoutes, ...extraRoutes];
                }

                displayRoute(allRoutes[0], 1, allRoutes.length);
            }
        }

        // Generar rutas alternativas con waypoints aleatorios
        async function generateAlternativeRoutes(start, end) {
            const alternatives = [];
            const midLat = (start.lat + end.lat) / 2;
            const midLng = (start.lng + end.lng) / 2;
            const distance = start.distanceTo(end);
            const offset = distance / 111000 * 0.15; // 15% de la distancia en grados

            // Generar 3 waypoints diferentes (izquierda, derecha, arriba)
            const offsets = [
                { lat: offset, lng: offset },      // Noreste
                { lat: -offset, lng: -offset },    // Suroeste
                { lat: offset, lng: -offset },     // Noroeste
                { lat: -offset, lng: offset },     // Sureste
                { lat: offset * 1.5, lng: 0 },     // Norte
                { lat: -offset * 1.5, lng: 0 },    // Sur
            ];

            for (const off of offsets) {
                try {
                    const waypoint = {
                        lat: midLat + off.lat + (Math.random() - 0.5) * offset * 0.5,
                        lng: midLng + off.lng + (Math.random() - 0.5) * offset * 0.5
                    };

                    const response = await fetch(
                        `https://router.project-osrm.org/route/v1/driving/${start.lng},${start.lat};${waypoint.lng},${waypoint.lat};${end.lng},${end.lat}?overview=full&geometries=geojson&steps=true`
                    );

                    if (response.ok) {
                        const data = await response.json();
                        if (data.routes && data.routes.length > 0) {
                            // Solo a√±adir si es significativamente diferente
                            const newDist = data.routes[0].distance;
                            const isDifferent = !alternatives.some(r =>
                                Math.abs(r.distance - newDist) < newDist * 0.05
                            );
                            if (isDifferent && alternatives.length < 5) {
                                alternatives.push(data.routes[0]);
                            }
                        }
                    }
                } catch (e) {
                    console.log('Error generando alternativa:', e);
                }
            }

            return alternatives;
        }

        // Mostrar una ruta espec√≠fica
        function displayRoute(route, index, total) {
            if (routeLayer) map.removeLayer(routeLayer);

            // Store route data for navigation
            routeCoordinates = route.geometry.coordinates.map(c => [c[1], c[0]]);
            routeSteps = route.legs ? route.legs[0].steps : [];
            totalDistance = route.distance;

            // Colores diferentes para cada ruta alternativa
            const colors = ['#f97316', '#10b981', '#8b5cf6', '#ec4899', '#06b6d4', '#eab308'];
            const routeColor = colors[(index - 1) % colors.length];

            const routeStyle = {
                color: routeColor,
                weight: 6,
                opacity: 0.85,
                dashArray: routeType === 'offroad' ? '12, 8' : null
            };

            routeLayer = L.geoJSON(route.geometry, { style: routeStyle }).addTo(map);
            map.fitBounds(routeLayer.getBounds(), { padding: [50, 50] });

            const distance = (route.distance / 1000).toFixed(1);

            // Calcular duraci√≥n - siempre estimar basado en distancia y velocidad
            // BRouter a veces da valores incorrectos, mejor calcular nosotros
            const avgSpeed = routeType === 'offroad' ? 25 : 50; // km/h
            let duration = Math.round((route.distance / 1000) / avgSpeed * 60); // minutos

            // Ajustar para off-road (terreno m√°s dif√≠cil)
            if (routeType === 'offroad') {
                duration = Math.round(duration * 1.2);
            }

            // Mostrar desnivel real si est√° disponible (BRouter)
            let elevation;
            if (route.ascend) {
                elevation = Math.round(route.ascend);
            } else {
                elevation = Math.round(parseFloat(distance) * 15); // Estimaci√≥n
            }

            document.getElementById('distance').textContent = `${distance} km`;

            // Formatear duraci√≥n: si es >= 60 min, mostrar en horas
            if (duration >= 60) {
                const hours = Math.floor(duration / 60);
                const mins = duration % 60;
                if (mins === 0) {
                    document.getElementById('duration').textContent = hours + 'h';
                } else {
                    document.getElementById('duration').textContent = hours + 'h ' + mins + 'm';
                }
            } else {
                document.getElementById('duration').textContent = duration + ' min';
            }
            document.getElementById('elevation').textContent = `‚Üë${elevation} m`;
            document.getElementById('routeInfo').classList.remove('hidden');

            // Mostrar el tipo de ruta
            const profileText = route.profile ? ` (${route.profile})` : '';

            if (total > 1) {
                showNotification(`üõ§Ô∏è Ruta ${index}/${total}${profileText} - ¬°Pulsa para ver otra!`);
            } else {
                showNotification(`‚úÖ Ruta calculada${profileText} - ¬°Pulsa INICIAR!`);
            }
        }

        // Start Navigation
        function startNavigation() {
            if (routeCoordinates.length === 0) {
                showNotification('‚ö†Ô∏è Primero calcula una ruta');
                return;
            }

            isNavigating = true;
            currentStepIndex = 0;

            // Hide planning UI, show navigation UI
            document.getElementById('menuPanel').classList.add('hidden');
            document.getElementById('fabContainer').classList.add('hidden');
            document.getElementById('navMode').classList.remove('hidden');

            // Crear marcador de veh√≠culo
            if (vehicleMarker) map.removeLayer(vehicleMarker);
            if (userMarker) map.removeLayer(userMarker);

            // Centrar en el inicio de la ruta primero
            const startPoint = L.latLng(routeCoordinates[0][0], routeCoordinates[0][1]);

            // Forzar actualizaci√≥n del mapa despu√©s de un peque√±o delay
            setTimeout(() => {
                map.invalidateSize();
                map.setView(startPoint, 15);

                // Crear marcador de veh√≠culo en el punto inicial
                vehicleMarker = L.marker(startPoint, {
                    icon: createVehicleIcon(0),
                    zIndexOffset: 1000
                }).addTo(map);

                // Forzar recarga de tiles
                setTimeout(() => {
                    map.invalidateSize();
                }, 100);
            }, 50);

            // Start watching position
            if ('geolocation' in navigator) {
                watchId = navigator.geolocation.watchPosition(
                    updateNavigation,
                    handleLocationError,
                    {
                        enableHighAccuracy: true,
                        maximumAge: 1000,
                        timeout: 10000
                    }
                );

                showNotification('üß≠ Navegaci√≥n iniciada - Esperando GPS...');
                document.getElementById('turnInstruction').textContent = 'Esperando se√±al GPS...';
                document.getElementById('turnDistance').textContent = 'Activa tu GPS';
            } else {
                showNotification('‚ö†Ô∏è Geolocalizaci√≥n no disponible en este dispositivo');
                document.getElementById('turnInstruction').textContent = 'GPS no disponible';
            }

            // Activar wake lock para mantener pantalla encendida
            requestWakeLock();

            // Initial UI update
            updateNavigationUI();


        }

        // Update navigation based on position
        function updateNavigation(position) {
            const lat = position.coords.latitude;
            const lng = position.coords.longitude;
            const accuracy = position.coords.accuracy;
            const speed = position.coords.speed;
            const heading = position.coords.heading;

            // Update speed
            currentSpeed = speed ? Math.round(speed * 3.6) : 0;
            document.getElementById('currentSpeed').textContent = currentSpeed;

            // Calcular heading si no est√° disponible
            const userLatLng = L.latLng(lat, lng);

            if (lastPosition) {
                const calculatedHeading = calculateBearing(lastPosition, userLatLng);
                if (calculatedHeading !== null && currentSpeed > 2) {
                    currentHeading = heading || calculatedHeading;
                }
            }

            // Update or create vehicle marker (flecha direccional)
            if (vehicleMarker) {
                vehicleMarker.setLatLng(userLatLng);
                vehicleMarker.setIcon(createVehicleIcon(currentHeading));
            } else {
                vehicleMarker = L.marker(userLatLng, {
                    icon: createVehicleIcon(currentHeading),
                    zIndexOffset: 1000
                }).addTo(map);
            }

            // El icono del veh√≠culo rota seg√∫n heading
            rotateMap(currentHeading);

            // Center map on user - zoom moderado para ver bien el mapa
            map.setView(userLatLng, 15);

            // Asegurar que el mapa se renderiza correctamente
            if (!map._loaded) {
                map.invalidateSize();
            }

            // Calculate distance to destination
            const destLatLng = L.latLng(routeCoordinates[routeCoordinates.length - 1]);
            const remainingDist = userLatLng.distanceTo(destLatLng);

            // Update remaining distance
            if (remainingDist > 1000) {
                document.getElementById('navRemaining').textContent = `${(remainingDist / 1000).toFixed(1)} km`;
            } else {
                document.getElementById('navRemaining').textContent = `${Math.round(remainingDist)} m`;
            }

            // Calculate progress
            const startLatLng = L.latLng(routeCoordinates[0]);
            const totalDist = startLatLng.distanceTo(destLatLng);
            const progress = Math.max(0, Math.min(100, ((totalDist - remainingDist) / totalDist) * 100));
            document.getElementById('progressFill').style.width = `${progress}%`;

            // Calculate ETA
            const avgSpeed = currentSpeed > 5 ? currentSpeed : 30; // Default 30 km/h
            const etaMinutes = Math.round((remainingDist / 1000) / avgSpeed * 60);
            const etaTime = new Date(Date.now() + etaMinutes * 60000);
            document.getElementById('navETA').textContent = etaTime.toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit' });

            // Find current step
            updateCurrentStep(userLatLng);

            // Check if arrived
            if (remainingDist < 50) {
                showNotification('üéâ ¬°Has llegado a tu destino!');
                stopNavigation();
            }

            lastPosition = userLatLng;
        }

        // Update current navigation step
        function updateCurrentStep(userLatLng) {
            if (!routeSteps || routeSteps.length === 0) return;

            // Find the closest step
            let minDist = Infinity;
            let closestStepIdx = currentStepIndex;

            for (let i = currentStepIndex; i < routeSteps.length; i++) {
                const step = routeSteps[i];
                const stepCoord = step.maneuver.location;
                const stepLatLng = L.latLng(stepCoord[1], stepCoord[0]);
                const dist = userLatLng.distanceTo(stepLatLng);

                if (dist < minDist) {
                    minDist = dist;
                    closestStepIdx = i;
                }
            }


            currentStepIndex = closestStepIdx;
            const currentStep = routeSteps[currentStepIndex];

            // Update turn instruction
            const maneuver = currentStep.maneuver;
            const turnType = maneuver.type || '';
            const modifier = maneuver.modifier || '';

            // Debug - ver qu√© valores llegan
            console.log('Turn:', turnType, 'Modifier:', modifier, 'Dist:', Math.round(minDist));

            // Detectar si es giro izquierda o derecha (varias formas posibles)
            const modLower = modifier.toLowerCase();
            const typeLower = turnType.toLowerCase();
            const isLeft = modLower.includes('left') || typeLower.includes('left');
            const isRight = modLower.includes('right') || typeLower.includes('right');
            const isRealTurn = isLeft || isRight;

            // Get turn icon
            const turnIcon = getTurnIcon(turnType, modifier);
            document.getElementById('turnIcon').innerHTML = '<i class="fas ' + turnIcon + '"></i>';

            // Distance to next maneuver
            if (minDist > 1000) {
                document.getElementById('turnDistance').textContent = (minDist / 1000).toFixed(1) + ' km';
            } else {
                document.getElementById('turnDistance').textContent = Math.round(minDist) + ' m';
            }

            // Instruction text
            const instruction = getInstructionText(turnType, modifier);
            document.getElementById('turnInstruction').textContent = instruction;
            document.getElementById('streetName').textContent = currentStep.name || 'Camino sin nombre';

            // Referencias a elementos
            const alertBanner = document.getElementById('alertBanner');
            const billboard = document.getElementById('turnBillboard');

            // Si es un giro real
            if (isRealTurn) {


                // Mostrar cartel si estamos cerca
                if (minDist < 500) {
                    showTurnBillboard(turnType, modifier, minDist, currentStep.name);

                    // Banner de alerta muy cerca
                    if (minDist < 100) {
                        alertBanner.classList.remove('hidden');
                        const dir = isLeft ? 'izquierda' : 'derecha';
                        document.getElementById('alertText').textContent = '¬°Gira a la ' + dir + ' en ' + Math.round(minDist) + 'm!';
                    } else {
                        alertBanner.classList.add('hidden');
                    }
                } else {
                    billboard.classList.remove('show');
                    alertBanner.classList.add('hidden');
                }
            } else {
                billboard.classList.remove('show');
                alertBanner.classList.add('hidden');
            }
        }

        // Mostrar indicador de giro compacto - SOLO para giros izquierda/derecha
        function showTurnBillboard(turnType, modifier, distance, streetName) {
            const billboard = document.getElementById('turnBillboard');
            const arrow = document.getElementById('billboardArrow');
            const text = document.getElementById('billboardText');
            const distEl = document.getElementById('billboardDistance');

            // Detectar giro (m√∫ltiples formatos posibles)
            const modLower = (modifier || '').toLowerCase();
            const typeLower = (turnType || '').toLowerCase();
            const isLeft = modLower.includes('left') || typeLower.includes('left');
            const isRight = modLower.includes('right') || typeLower.includes('right');

            if (!isLeft && !isRight) {
                billboard.classList.remove('show');
                return;
            }

            // Determinar icono y texto
            if (isLeft) {
                arrow.innerHTML = '<i class="fas fa-arrow-left"></i>';
                text.textContent = 'Gira a la izquierda';
            } else {
                arrow.innerHTML = '<i class="fas fa-arrow-right"></i>';
                text.textContent = 'Gira a la derecha';
            }

            if (distance > 1000) {
                distEl.textContent = (distance / 1000).toFixed(1) + ' km';
            } else {
                distEl.textContent = Math.round(distance) + ' m';
            }

            billboard.classList.add('show');

            // Ocultar despu√©s de 4 segundos
            clearTimeout(billboardTimeout);
            billboardTimeout = setTimeout(function () {
                billboard.classList.remove('show');
            }, 4000);
        }

        // Calcular bearing entre dos puntos
        function calculateBearing(start, end) {
            if (!start || !end) return 0;

            const startLat = start.lat * Math.PI / 180;
            const startLng = start.lng * Math.PI / 180;
            const endLat = end.lat * Math.PI / 180;
            const endLng = end.lng * Math.PI / 180;

            const dLng = endLng - startLng;

            const x = Math.sin(dLng) * Math.cos(endLat);
            const y = Math.cos(startLat) * Math.sin(endLat) - Math.sin(startLat) * Math.cos(endLat) * Math.cos(dLng);

            let bearing = Math.atan2(x, y) * 180 / Math.PI;
            return (bearing + 360) % 360;
        }

        // Rotar el mapa seg√∫n heading (desactivado - causa problemas de renderizado)
        function rotateMap(heading) {
            // El icono del veh√≠culo ya rota, no necesitamos rotar el mapa
            mapRotation = heading;
        }

        function getTurnIcon(type, modifier) {
            const icons = {
                'turn-left': 'fa-arrow-left',
                'turn-right': 'fa-arrow-right',
                'sharp left': 'fa-arrow-left',
                'sharp right': 'fa-arrow-right',
                'slight left': 'fa-arrow-up',
                'slight right': 'fa-arrow-up',
                'straight': 'fa-arrow-up',
                'uturn': 'fa-rotate-left',
                'roundabout': 'fa-rotate-right',
                'arrive': 'fa-flag-checkered',
                'depart': 'fa-play'
            };

            if (modifier && icons[modifier]) return icons[modifier];
            if (icons[type]) return icons[type];
            return 'fa-arrow-up';
        }

        function getInstructionText(type, modifier) {
            const instructions = {
                'turn': {
                    'left': 'Gira a la izquierda',
                    'right': 'Gira a la derecha',
                    'sharp left': 'Giro cerrado a la izquierda',
                    'sharp right': 'Giro cerrado a la derecha',
                    'slight left': 'Mantente a la izquierda',
                    'slight right': 'Mantente a la derecha',
                    'straight': 'Contin√∫a recto'
                },
                'arrive': 'Llegada al destino',
                'depart': 'Inicia el recorrido',
                'roundabout': 'Entra en la rotonda',
                'fork': modifier?.includes('left') ? 'Toma el desv√≠o izquierdo' : 'Toma el desv√≠o derecho',
                'merge': 'Incorp√≥rate',
                'new name': 'Contin√∫a por',
                'continue': 'Contin√∫a recto'
            };

            if (type === 'turn' && modifier) {
                return instructions.turn[modifier] || 'Contin√∫a';
            }
            return instructions[type] || 'Contin√∫a recto';
        }

        function handleLocationError(error) {
            console.error('Location error:', error);
            showNotification('‚ö†Ô∏è Error de GPS. Verifica los permisos de ubicaci√≥n.');
            document.getElementById('turnInstruction').textContent = 'Esperando se√±al GPS...';
            document.getElementById('turnDistance').textContent = '--';

            // Reintentar obtener ubicaci√≥n cada 5 segundos
            setTimeout(() => {
                if (isNavigating) {
                    navigator.geolocation.getCurrentPosition(
                        updateNavigation,
                        handleLocationError,
                        { enableHighAccuracy: true, timeout: 10000 }
                    );
                }
            }, 5000);
        }



        // Stop navigation
        function stopNavigation() {
            isNavigating = false;


            if (watchId) {
                navigator.geolocation.clearWatch(watchId);
                watchId = null;
            }

            // Desactivar modo navegaci√≥n
            const mapContainer = document.getElementById('map');
            mapContainer.classList.remove('navigation-mode');

            // Ocultar cartel de giro
            document.getElementById('turnBillboard').classList.remove('show');

            // Limpiar marcador de veh√≠culo
            if (vehicleMarker) {
                map.removeLayer(vehicleMarker);
                vehicleMarker = null;
            }

            // Restaurar zoom
            map.setZoom(14);

            // Show planning UI, hide navigation UI
            document.getElementById('menuPanel').classList.remove('hidden');
            document.getElementById('fabContainer').classList.remove('hidden');
            document.getElementById('navMode').classList.add('hidden');

            showNotification('üõë Navegaci√≥n finalizada');
        }

        // Center on user
        function centerOnUser() {
            if (vehicleMarker) {
                map.setView(vehicleMarker.getLatLng(), 15);
            } else if (userMarker) {
                map.setView(userMarker.getLatLng(), 15);
            }
        }

        // Update navigation UI
        function updateNavigationUI() {
            if (routeSteps && routeSteps.length > 0) {
                const firstStep = routeSteps[0];
                document.getElementById('turnInstruction').textContent = 'Inicia el recorrido';
                document.getElementById('streetName').textContent = firstStep.name || 'Ruta off-road';
                document.getElementById('navRemaining').textContent = `${(totalDistance / 1000).toFixed(1)} km`;
            }
        }

        function showNotification(message) {
            const existing = document.querySelector('.notification-toast');
            if (existing) existing.remove();

            const notification = document.createElement('div');
            notification.className = 'notification-toast';
            notification.innerHTML = message;
            document.body.appendChild(notification);

            // Animaci√≥n de entrada
            notification.style.opacity = '0';
            notification.style.transform = 'translateY(20px)';
            requestAnimationFrame(() => {
                notification.style.transition = 'all 0.3s ease';
                notification.style.opacity = '1';
                notification.style.transform = 'translateY(0)';
            });

            setTimeout(() => {
                notification.style.opacity = '0';
                notification.style.transform = 'translateY(20px)';
                setTimeout(() => notification.remove(), 300);
            }, 3500);
        }

        function clearAll() {
            if (markerA) map.removeLayer(markerA);
            if (markerB) map.removeLayer(markerB);
            if (routeLayer) map.removeLayer(routeLayer);
            if (userMarker) map.removeLayer(userMarker);

            markerA = null;
            markerB = null;
            routeLayer = null;
            userMarker = null;
            routeCoordinates = [];
            routeSteps = [];
            currentMode = 'A';

            // Limpiar rutas alternativas
            allRoutes = [];
            currentRouteIndex = 0;
            lastRouteRequest = null;

            // Clear search inputs
            searchInputA.value = '';
            searchInputB.value = '';
            clearSearchA.style.display = 'none';
            clearSearchB.style.display = 'none';
            loadingA.style.display = 'none';
            loadingB.style.display = 'none';
            resultsA.classList.remove('show');
            resultsB.classList.remove('show');

            document.getElementById('routeInfo').classList.add('hidden');
            updateButtonStyles();
            showNotification('üóëÔ∏è Mapa limpiado');
        }

        // ==========================================
        // SEARCH FUNCTIONALITY WITH AUTOCOMPLETE
        // ==========================================

        let searchTimeoutA = null;
        let searchTimeoutB = null;

        const searchInputA = document.getElementById('searchInputA');
        const searchInputB = document.getElementById('searchInputB');
        const resultsA = document.getElementById('resultsA');
        const resultsB = document.getElementById('resultsB');
        const clearSearchA = document.getElementById('clearSearchA');
        const clearSearchB = document.getElementById('clearSearchB');
        const loadingA = document.getElementById('loadingA');
        const loadingB = document.getElementById('loadingB');

        // Search input A
        searchInputA.addEventListener('input', (e) => {
            const query = e.target.value.trim();
            clearTimeout(searchTimeoutA);

            if (query.length < 3) {
                resultsA.classList.remove('show');
                clearSearchA.style.display = 'none';
                loadingA.style.display = 'none';
                return;
            }

            loadingA.style.display = 'block';
            clearSearchA.style.display = 'none';

            searchTimeoutA = setTimeout(() => searchAddress(query, 'A'), 500);
        });

        // Search input B
        searchInputB.addEventListener('input', (e) => {
            const query = e.target.value.trim();
            clearTimeout(searchTimeoutB);

            if (query.length < 3) {
                resultsB.classList.remove('show');
                clearSearchB.style.display = 'none';
                loadingB.style.display = 'none';
                return;
            }

            loadingB.style.display = 'block';
            clearSearchB.style.display = 'none';

            searchTimeoutB = setTimeout(() => searchAddress(query, 'B'), 500);
        });

        // Clear buttons
        clearSearchA.addEventListener('click', () => {
            searchInputA.value = '';
            resultsA.classList.remove('show');
            clearSearchA.style.display = 'none';
            if (markerA) {
                map.removeLayer(markerA);
                markerA = null;
            }
        });

        clearSearchB.addEventListener('click', () => {
            searchInputB.value = '';
            resultsB.classList.remove('show');
            clearSearchB.style.display = 'none';
            if (markerB) {
                map.removeLayer(markerB);
                markerB = null;
            }
        });

        // Search address using Nominatim
        async function searchAddress(query, point) {
            const resultsDiv = point === 'A' ? resultsA : resultsB;
            const loadingEl = point === 'A' ? loadingA : loadingB;
            const clearEl = point === 'A' ? clearSearchA : clearSearchB;

            try {
                const response = await fetch(
                    `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}&limit=5&addressdetails=1`,
                    {
                        headers: {
                            'Accept-Language': 'es'
                        }
                    }
                );

                const data = await response.json();

                loadingEl.style.display = 'none';
                clearEl.style.display = 'block';

                if (data.length === 0) {
                    resultsDiv.innerHTML = `
                        <div class="search-result-item text-gray-400">
                            <i class="fas fa-info-circle"></i>
                            <span>No se encontraron resultados</span>
                        </div>
                    `;
                    resultsDiv.classList.add('show');
                    return;
                }

                resultsDiv.innerHTML = data.map((item, index) => `
                    <div class="search-result-item" data-lat="${item.lat}" data-lon="${item.lon}" data-name="${item.display_name}" data-point="${point}">
                        <i class="fas ${getPlaceIcon(item.type)}"></i>
                        <div>
                            <div class="font-medium text-white">${getShortName(item)}</div>
                            <div class="text-xs text-gray-400 mt-1">${item.display_name}</div>
                        </div>
                    </div>
                `).join('');

                resultsDiv.classList.add('show');

                // Add click handlers to results
                resultsDiv.querySelectorAll('.search-result-item[data-lat]').forEach(item => {
                    item.addEventListener('click', () => selectSearchResult(item));
                });

            } catch (error) {
                console.error('Search error:', error);
                loadingEl.style.display = 'none';
                clearEl.style.display = 'block';
                resultsDiv.innerHTML = `
                    <div class="search-result-item text-red-400">
                        <i class="fas fa-exclamation-circle"></i>
                        <span>Error al buscar. Intenta de nuevo.</span>
                    </div>
                `;
                resultsDiv.classList.add('show');
            }
        }

        function getPlaceIcon(type) {
            const icons = {
                'city': 'fa-city',
                'town': 'fa-city',
                'village': 'fa-home',
                'hamlet': 'fa-home',
                'suburb': 'fa-building',
                'neighbourhood': 'fa-building',
                'road': 'fa-road',
                'path': 'fa-hiking',
                'track': 'fa-mountain',
                'footway': 'fa-shoe-prints',
                'cycleway': 'fa-bicycle',
                'peak': 'fa-mountain',
                'hill': 'fa-mountain',
                'forest': 'fa-tree',
                'wood': 'fa-tree',
                'park': 'fa-tree',
                'river': 'fa-water',
                'stream': 'fa-water',
                'lake': 'fa-water'
            };
            return icons[type] || 'fa-map-marker-alt';
        }

        function getShortName(item) {
            if (item.address) {
                if (item.address.road) return item.address.road;
                if (item.address.village) return item.address.village;
                if (item.address.town) return item.address.town;
                if (item.address.city) return item.address.city;
                if (item.address.municipality) return item.address.municipality;
            }
            return item.display_name.split(',')[0];
        }

        function selectSearchResult(item) {
            const lat = parseFloat(item.dataset.lat);
            const lon = parseFloat(item.dataset.lon);
            const name = item.dataset.name;
            const point = item.dataset.point;

            const latlng = L.latLng(lat, lon);

            if (point === 'A') {
                if (markerA) map.removeLayer(markerA);
                markerA = L.marker(latlng, {
                    icon: createMarkerIcon('A', '#22c55e'),
                    draggable: true
                }).addTo(map);
                markerA.bindPopup(`<b>Inicio:</b><br>${name.split(',').slice(0, 2).join(',')}`);

                searchInputA.value = getShortName({ display_name: name, address: null });
                resultsA.classList.remove('show');
                clearSearchA.style.display = 'block';

                // Auto-focus to point B
                searchInputB.focus();
            } else {
                if (markerB) map.removeLayer(markerB);
                markerB = L.marker(latlng, {
                    icon: createMarkerIcon('B', '#ef4444'),
                    draggable: true
                }).addTo(map);
                markerB.bindPopup(`<b>Destino:</b><br>${name.split(',').slice(0, 2).join(',')}`);

                searchInputB.value = getShortName({ display_name: name, address: null });
                resultsB.classList.remove('show');
                clearSearchB.style.display = 'block';
            }

            // Zoom to marker
            map.setView(latlng, 14);

            // If both markers exist, fit bounds
            if (markerA && markerB) {
                const group = L.featureGroup([markerA, markerB]);
                map.fitBounds(group.getBounds(), { padding: [50, 50] });
            }
        }

        // Close search results when clicking outside
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.search-container')) {
                resultsA.classList.remove('show');
                resultsB.classList.remove('show');
            }
        });

        // Use current location as start point
        document.getElementById('btnLocate').addEventListener('click', () => {
            if ('geolocation' in navigator) {
                navigator.geolocation.getCurrentPosition(
                    (position) => {
                        const latlng = L.latLng(position.coords.latitude, position.coords.longitude);

                        if (markerA) map.removeLayer(markerA);
                        markerA = L.marker(latlng, {
                            icon: createMarkerIcon('A', '#22c55e'),
                            draggable: true
                        }).addTo(map);
                        markerA.bindPopup('<b>Tu ubicaci√≥n actual</b>');

                        searchInputA.value = 'üìç Mi ubicaci√≥n actual';
                        clearSearchA.style.display = 'block';

                        map.setView(latlng, 15);
                        showNotification('üìç Ubicaci√≥n establecida como punto de inicio');
                    },
                    (error) => {
                        showNotification('‚ö†Ô∏è No se pudo obtener tu ubicaci√≥n');
                    },
                    { enableHighAccuracy: true }
                );
            }
        });

        // ==========================================
        // NAVEGACI√ìN GPS CON ROTACI√ìN
        // ==========================================

        let testRotationInterval = null;
        let testHeading = 0;

        function startNavigation() {
            if (routeCoordinates.length === 0) {
                showNotification('‚ö†Ô∏è Primero calcula una ruta');
                return;
            }

            isNavigating = true;

            // Activar vista GPS
            enableGPSView();

            // Ocultar men√∫ de planificaci√≥n y mostrar UI de navegaci√≥n
            document.getElementById('menuPanel').style.display = 'none';
            document.getElementById('navMode').classList.remove('hidden');
            document.getElementById('fabContainer').style.display = 'none';

            // Crear marcador de veh√≠culo si no existe
            if (!vehicleMarker && routeCoordinates.length > 0) {
                const startPos = L.latLng(routeCoordinates[0]);
                vehicleMarker = L.marker(startPos, {
                    icon: createVehicleIcon(0)
                }).addTo(map);
            }

            // Iniciar seguimiento GPS
            if ('geolocation' in navigator) {
                watchId = navigator.geolocation.watchPosition(
                    updateNavigationPosition,
                    (error) => {
                        console.error('GPS error:', error);
                        showNotification('‚ö†Ô∏è Error al obtener ubicaci√≥n GPS');
                    },
                    {
                        enableHighAccuracy: true,
                        maximumAge: 0,
                        timeout: 5000
                    }
                );
            }

            // MODO PRUEBA: Simular rotaci√≥n para testing (solo si no hay movimiento real)
            // Esto rotar√° autom√°ticamente el mapa para que veas c√≥mo funciona
            setTimeout(() => {
                if (currentHeading === 0) {
                    console.log('üîÑ Iniciando rotaci√≥n de prueba (sin movimiento GPS detectado)');
                    testRotationInterval = setInterval(() => {
                        testHeading = (testHeading + 5) % 360;
                        currentHeading = testHeading;
                        setMapRotation(testHeading);
                        if (vehicleMarker) {
                            vehicleMarker.setIcon(createVehicleIcon(testHeading));
                        }
                        console.log('üß™ Test heading:', testHeading, '¬∞');
                    }, 1000);
                }
            }, 3000); // Esperar 3 segundos antes de iniciar rotaci√≥n de prueba

            // Wake lock para mantener pantalla encendida
            requestWakeLock();

            // GRACE PERIOD: Evitar que se detecte "llegada" inmediatamente si el GPS salta
            navigationStartTime = Date.now();

            showNotification('üß≠ Navegaci√≥n iniciada - GPS activado');
        }


        function updateNavigationPosition(position) {
            if (!isNavigating) return;

            const lat = position.coords.latitude;
            const lng = position.coords.longitude;
            const userLatLng = L.latLng(lat, lng);

            // Actualizar velocidad
            if (position.coords.speed && position.coords.speed > 0) {
                currentSpeed = Math.round(position.coords.speed * 3.6); // m/s a km/h
            }
            document.getElementById('currentSpeed').textContent = currentSpeed;

            // Calcular heading basado en el movimiento
            let heading = currentHeading;
            if (lastPosition) {
                heading = calculateBearing(lastPosition, userLatLng);
                currentHeading = heading;
                console.log('üìç Heading calculado:', heading.toFixed(2), '¬∞');

                // Detener rotaci√≥n de prueba si hay movimiento real
                if (testRotationInterval) {
                    clearInterval(testRotationInterval);
                    testRotationInterval = null;
                    console.log('‚úÖ Movimiento GPS detectado - Deteniendo rotaci√≥n de prueba');
                }
            } else if (position.coords.heading !== null && position.coords.heading >= 0) {
                heading = position.coords.heading;
                currentHeading = heading;
                console.log('üì± Heading del sensor:', heading.toFixed(2), '¬∞');

                // Detener rotaci√≥n de prueba si hay br√∫jula
                if (testRotationInterval) {
                    clearInterval(testRotationInterval);
                    testRotationInterval = null;
                    console.log('‚úÖ Br√∫jula detectada - Deteniendo rotaci√≥n de prueba');
                }
            }


            // Actualizar marcador de veh√≠culo con rotaci√≥n
            if (vehicleMarker) {
                vehicleMarker.setLatLng(userLatLng);
                vehicleMarker.setIcon(createVehicleIcon(heading));
            }

            // CLAVE: Rotar el mapa para que el veh√≠culo siempre apunte hacia arriba
            console.log('üó∫Ô∏è Aplicando rotaci√≥n del mapa:', -heading.toFixed(2), '¬∞');
            setMapRotation(heading);

            // Centrar mapa ADELANTE de la posici√≥n del usuario para ver m√°s carretera
            // Offset de 250 metros en la direcci√≥n del movimiento
            const offsetCenter = calculateDestinationPoint(userLatLng, heading, 250);

            // Centrar mapa en el punto offset (c√°mara detr√°s del veh√≠culo)
            map.setView(offsetCenter, 17, { animate: true });


            // Calcular distancia y ETA al destino
            if (routeCoordinates.length > 0) {
                const destLatLng = L.latLng(routeCoordinates[routeCoordinates.length - 1]);
                const remainingDist = userLatLng.distanceTo(destLatLng);

                // Actualizar distancia restante
                if (remainingDist > 1000) {
                    document.getElementById('navRemaining').textContent = (remainingDist / 1000).toFixed(1) + ' km';
                } else {
                    document.getElementById('navRemaining').textContent = Math.round(remainingDist) + ' m';
                }

                // Actualizar progreso
                const startLatLng = L.latLng(routeCoordinates[0]);
                const totalDist = startLatLng.distanceTo(destLatLng);
                const progress = Math.max(0, Math.min(100, ((totalDist - remainingDist) / totalDist) * 100));
                document.getElementById('progressFill').style.width = progress + '%';

                // Calcular ETA
                const avgSpeed = currentSpeed > 0 ? currentSpeed : 30; // km/h por defecto
                const etaMinutes = Math.round((remainingDist / 1000) / avgSpeed * 60);
                const etaTime = new Date(Date.now() + etaMinutes * 60000);
                document.getElementById('navETA').textContent = etaTime.toLocaleTimeString('es-ES', {
                    hour: '2-digit',
                    minute: '2-digit'
                });

                // Verificar si ha llegado al destino
                // GRACE PERIOD: Esperar al menos 10 segundos antes de permitir "llegada"
                const elapsed = Date.now() - navigationStartTime;

                if (remainingDist < 30 && elapsed > 10000) {
                    speak('Has llegado a tu destino');
                    showNotification('üéâ ¬°Has llegado!');
                    stopNavigation('destination_reached');
                }
            }

            lastPosition = userLatLng;
        }

        function stopNavigation() {
            isNavigating = false;

            // Desactivar vista GPS y volver a norte arriba
            disableGPSView();

            // Detener rotaci√≥n de prueba si est√° activa
            if (testRotationInterval) {
                clearInterval(testRotationInterval);
                testRotationInterval = null;
                testHeading = 0;
            }

            // Detener seguimiento GPS
            if (watchId) {
                navigator.geolocation.clearWatch(watchId);
                watchId = null;
            }


            // Mostrar men√∫ de planificaci√≥n y ocultar UI de navegaci√≥n
            document.getElementById('menuPanel').style.display = 'block';
            document.getElementById('navMode').classList.add('hidden');
            document.getElementById('fabContainer').style.display = 'flex';

            // Remover marcador de veh√≠culo
            if (vehicleMarker) {
                map.removeLayer(vehicleMarker);
                vehicleMarker = null;
            }

            // Resetear variables
            lastPosition = null;
            currentSpeed = 0;
            currentHeading = 0;

            showNotification('‚èπÔ∏è Navegaci√≥n detenida');
        }

        function centerOnUser() {
            let target = lastPosition;
            let heading = currentHeading;

            if (vehicleMarker) {
                target = vehicleMarker.getLatLng();
            } else if (!target) {
                showNotification('üìç No hay ubicaci√≥n GPS disponible');
                return;
            }

            // Usar offset si estamos navegando
            if (isNavigating) {
                const offsetCenter = calculateDestinationPoint(target, heading, 250);
                map.setView(offsetCenter, 17);
            } else {
                map.setView(target, 16);
            }
        }

        // Funci√≥n de s√≠ntesis de voz para notificaciones
        function speak(text) {
            if ('speechSynthesis' in window) {
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.lang = 'es-ES';
                utterance.rate = 1.0;
                speechSynthesis.speak(utterance);
            }
        }

        // Initialize
        updateButtonStyles();
        updateRouteTypeButtons();

        // Geolocation events
        map.on('locationfound', function (e) {
            if (!isNavigating && !userMarker) {
                userMarker = L.marker(e.latlng, {
                    icon: createUserIcon()
                }).addTo(map);
            }
        });

        map.on('locationerror', function (e) {
            showNotification('üìç No se pudo obtener tu ubicaci√≥n');
        });

        // Register Service Worker for PWA
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./sw.js')
                    .then(registration => {
                        console.log('SW registered:', registration.scope);
                    })
                    .catch(error => {
                        console.log('SW registration failed:', error);
                    });
            });
        }

        // Prevent pull-to-refresh on mobile
        document.body.addEventListener('touchmove', function (e) {
            if (e.target.closest('#map')) return;
            e.preventDefault();
        }, { passive: false });

        // Handle app install prompt
        let deferredPrompt;
        window.addEventListener('beforeinstallprompt', (e) => {
            e.preventDefault();
            deferredPrompt = e;
            // Could show an install button here
        });

        // Wake lock to keep screen on during navigation
        async function requestWakeLock() {
            if ('wakeLock' in navigator && isNavigating) {
                try {
                    await navigator.wakeLock.request('screen');
                    console.log('Wake lock active');
                } catch (err) {
                    console.log('Wake lock error:', err);
                }
            }
        }
    </script>
</body>

</html>